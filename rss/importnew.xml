<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>ImportNew - chuansong.me</title><link>http://chuansong.me/account/importnew</link><description>专注 Java 和 Android 技术分享。ImportNew 由两个 Java 关键字 import 和 new 组成。意指：Java</description><lastBuildDate>Fri, 30 Dec 2016 11:56:54 -0000</lastBuildDate><ttl>10</ttl><item><title>深入理解 Java G1 垃圾收集器</title><link>http://chuansong.me/n/1424007725836</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); line-height: 25.6px; text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 0, 0); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;(点击&lt;span style="max-width: 100%; color: rgb(0, 112, 192); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方蓝字&lt;/span&gt;，快速关注我们)&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; font-size: 16.1905px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; line-height: 1.6; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：伯乐在线专栏作者 - 卢亮&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="0Deicc" href="http://chuansong.me/n/351521825448" style="white-space: normal; background-color: rgb(255, 255, 255); max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; background-color: rgb(255, 254, 213); color: rgb(255, 0, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;如果转载，请发送「转载」二字查看说明&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;本文首先简单介绍了垃圾收集的常见方式，然后再分析了G1收集器的收集原理，相比其他垃圾收集器的优势，最后给出了一些调优实践。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;一，什么是垃圾回收&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;首先，在了解G1之前，我们需要清楚的知道，垃圾回收是什么？简单的说垃圾回收就是回收内存中不再使用的对象。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;垃圾回收的基本步骤&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;回收的步骤有2步：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;查找内存中不再使用的对象&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;释放这些对象占用的内存&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;1,查找内存中不再使用的对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;那么问题来了，如何判断哪些对象不再被使用呢？我们也有2个方法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;引用计数法&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;2.根搜索算法&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;现在我们已经知道如何找出垃圾对象了，如何把这些对象清理掉呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;2. 释放这些对象占用的内存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;常见的方式有复制或者直接清理，但是直接清理会存在内存碎片，于是就会产生了清理再压缩的方式。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;总得来说就产生了三种类型的回收算法。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;标记-复制&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次理掉。它的优点是实现简单，效率高，不会存在内存碎片。缺点就是需要2倍的内存来管理。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;标记-清理&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。它的优点是效率高，缺点是容易产生内存碎片。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;标记-整理&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;标记操作和“标记-清理”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有 存活的对象都向一端移动，并更新引用其对象的指针。因为要移动对象，所以它的效率要比“标记-清理”效率低，但是不会产生内存碎片。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;基于分代的假设&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;由于对象的存活时间有长有短，所以对于存活时间长的对象，减少被gc的次数可以避免不必要的开销。这样我们就把内存分成新生代和老年代，新生代存放刚创建的和存活时间比较短的对象，老年代存放存活时间比较长的对象。这样每次仅仅清理年轻代，老年代仅在必要时时再做清理可以极大的提高GC效率，节省GC时间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;java垃圾收集器的历史&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一阶段，Serial（串行）收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在jdk1.3.1之前，java虚拟机仅仅能使用Serial收集器。 Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;PS：开启Serial收集器的方式&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseSerialGC&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二阶段，Parallel（并行）收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Parallel收集器也称吞吐量收集器，相比Serial收集器，Parallel最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低gc时间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;PS:开启Parallel收集器的方式&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseParallelGC -XX:+UseParallelOldGC&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第三阶段，CMS（并发）收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;CMS收集器在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;PS:开启CMS收集器的方式&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseParNewGC -XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第四阶段，G1（并发）收集器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;G1收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。相对于CMS的优势而言是内存碎片的产生率大大降低。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;PS:开启G1收集器的方式&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseG1GC&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;二，了解G1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;G1的第一篇paper（附录1）发表于2004年，在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。为何oracle要极力推荐G1呢，G1有哪些优点？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;首先，G1的设计原则就是简单可行的性能调优&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;开发人员仅仅需要声明以下参数即可：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;其次，G1将新生代，老年代的物理空间划分取消了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109172" data-ratio="0.615686274509804" data-type="png" data-w="510" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KmUIPX7LLs4JMDj0WLuHdHfLBiafsh1JKrqhkrJ82jVLzgTzhPfsxpiaA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109173" data-ratio="0.4111600587371512" data-type="png" data-w="681" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KibiaRMwbY5iaOTEjzsJARMScrGUkHPgiaN6cibs2x1l13MdHcGWkgyiaj4AQ/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;PS：在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;对象分配策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Eden区中分配&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Humongous区分配&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;最后，G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。下面我们将分别介绍一下这2种模式。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;三，G1 Young GC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109174" data-ratio="0.38333333333333336" data-type="png" data-w="720" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KKYgQpCLNIkB3F1gACS0SibWVsBjnkuv61ibCPjqw79h4cgqpl5D1HFoQ/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 15px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-109175" data-ratio="0.36944444444444446" data-type="png" data-w="720" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9K7Qj8s0iburVndNeMEAOeFEqGQyVicLWF4PFhebdDf8RAXYqpQhR07NKg/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both;"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109176" data-ratio="0.571150097465887" data-type="png" data-w="513" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KPGfcP8icRBrmJ5gtsb27F1GgDWeajKYktIt1rboJAxw0SmCp2pIFcRA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Young GC 阶段：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;阶段1：根扫描&lt;/p&gt;&lt;p&gt;静态和本地对象被扫描&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;阶段2：更新RS&lt;/p&gt;&lt;p&gt;处理dirty card队列更新RS&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;阶段3：处理RS&lt;/p&gt;&lt;p&gt;检测从年轻代指向年老代的对象&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;阶段4：对象拷贝&lt;/p&gt;&lt;p&gt;拷贝存活的对象到survivor/old区域&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;阶段5：处理引用队列&lt;/p&gt;&lt;p&gt;软引用，弱引用，虚引用处理&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;四，G1 Mix GC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;它的GC步骤分2步：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;全局并发标记（global concurrent marking）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拷贝存活对象（evacuation）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;初始标记（initial mark，STW）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;根区域扫描（root region scan）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;并发标记（Concurrent Marking）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最终标记（Remark，STW）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;清除垃圾（Cleanup，STW）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;三色标记算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;黑色:根对象，或者该对象与它的子对象都被扫描&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;灰色:对象本身被扫描,但还没扫描完该对象中的子对象&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当GC开始扫描对象时，按照如下图步骤进行对象的扫描：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;根对象被置为黑色，子对象被置为灰色。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 15px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-109177" data-ratio="0.5909090909090909" data-type="png" data-w="550" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KlwMK5jtsKQic5YSll7eWe6JPmVNYC3NKsrG6wuLZnSJQrEnYlx3ZISw/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both;"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;继续由灰色遍历,将已扫描了子对象的对象置为黑色。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style=" border-width: 0px; border-style: initial; border-color: initial; margin-bottom: 20px; font-size: 15px; color: rgb(46, 46, 46) ; ; ; ; ; ; ; ; ; "&gt;&lt;a style="border-width: 0px; border-style: initial; border-color: initial; color: rgb(0, 153, 204);"&gt;&lt;img class="alignnone size-full wp-image-109178" data-ratio="0.6186612576064908" data-type="png" data-w="493" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KzNXQ81jtsGEn5ewp7nJEa3He14qJZDQhp4924z2gWndEBweH4lqjlw/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both;"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109179" data-ratio="0.6190476190476191" data-type="png" data-w="504" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9K21E3iaDueDiaibd1MqclZCLTfm0hUCQ3uPQvDETiab0s8lMtf31w9NdSRw/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们看下面一种情况，当垃圾收集器扫描到下面情况时：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109180" data-ratio="1.027681660899654" data-type="png" data-w="289" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KGPB6j41Vmu9e5dGoOc5zMJt3W5ibcfmlyEHwRffr4SIDdljKyibZDGJQ/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这时候应用程序执行了以下操作：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;A.c=C&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;B.c=null&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这样，对象的状态图变成如下情形：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109181" data-ratio="0.9830508474576272" data-type="png" data-w="295" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KQd33ibXYTze1U9WSe3NRPBU8N1Ako6Y4BKuIKLpFTIGWFrLnsUCl77A/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这时候垃圾收集器再标记扫描的时候就会下图成这样：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109182" data-ratio="0.9738562091503268" data-type="png" data-w="306" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9Ksy9ILFUNNB3uvEDgzw3E8lMzwLVFGGcJa3JKGDMxglrjZKIiaeuiaOMA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;在插入的时候记录对象&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在删除的时候记录对象&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;刚好这对应CMS和G1的2种不同实现方式：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;1，在开始标记的时候生成一个快照图标记存活对象&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;3，可能存在游离的垃圾，将在下次被收集&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-109183" data-ratio="0.5245098039215687" data-type="png" data-w="612" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KhKy0hAxdvxLKE6GPlEA4SVBH72oC88sOmZl9vgyicFLGsJJicoHfZeibA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。&lt;/p&gt;&lt;p&gt;&lt;img class="alignnone size-full wp-image-109184" data-ratio="0.4236760124610592" data-type="png" data-w="642" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KkP3JWhsbU2ULYJnD2lz9T6ibfCQIQhh71eskvYRtJIHKTRNu9w8QfBA/0?wx_fmt=png" style=" text-align: center; border-width: 0px; border-style: initial; border-color: initial; margin: auto; font-size: 0px; color: transparent; vertical-align: middle; display: block; clear: both ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;至此，混合式GC告一段落了。下一小节我们讲进入调优实践。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;五，调优实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;MaxGCPauseMillis调优&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;前面介绍过使用GC的最基本的参数：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;前面2个参数都好理解，后面这个MaxGCPauseMillis参数该怎么配置呢？这个参数从字面的意思上看，就是允许的GC最大的暂停时间。G1尽量确保每次GC暂停的时间都在设置的MaxGCPauseMillis范围内。 那G1是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;Young GC：选定所有新生代里的region。通过控制新生代的region个数来控制young GC的开销。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Mixed GC：选定所有新生代里的region，外加根据global concurrent marking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代region。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;&lt;strong&gt;其他调优参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;-XX:G1HeapRegionSize=n&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;-XX:ParallelGCThreads=n&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;-XX:ConcGCThreads=n&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;-XX:InitiatingHeapOccupancyPercent=45&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;避免使用以下参数：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;触发Full GC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在某些情况下，G1触发了Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生Full GC的情况有哪些呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;并发模式失败&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;晋升失败或者疏散失败&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;a,增加 -XX:G1ReservePercent 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;b,通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;c,也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;巨型对象分配失败&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当巨型对象找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;由于篇幅有限，G1还有很多调优实践，在此就不一一列出了，大家在平常的实践中可以慢慢探索。最后，期待java 9能正式发布，默认使用G1为垃圾收集器的java性能会不会又提高呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;附录：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;（1），The original G1 paper: Detlefs, D., Flood, C., Heller, S., and Printezis, T. 2004. Garbage-first garbage collection. In Proceedings of the 4th international Symposium on Memory Management (Vancouver, BC, Canada, October 24 – 25, 2004)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 20px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;专栏作者简介 &lt;/span&gt;&lt;/strong&gt;&lt;span style="max-width: 100%; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（ &lt;/span&gt;&lt;a csmlink="GDeicc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;点击 → 加入专栏作者&lt;/span&gt;&lt;/a&gt;&lt;span style="max-width: 100%; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt; ）&lt;/span&gt;&lt;/p&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;卢亮：精益求精的技术员。&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1424007725836</guid></item><item><title>Java 消息队列任务的平滑关闭</title><link>http://chuansong.me/n/1424007825838</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：蛙牛&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：my.oschina.net/lujianing/blog/787745&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="ADeicc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;1.问题背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于消息队列的监听，我们一般使用Java写一个独立的程序，在Linux服务器上运行。程序启动后，通过消息队列客户端接收消息，放入一个线程池进行异步处理，并发的快速处理。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;那么问题来了，当我们修改程序后，需要重新启动任务的时候，如何保证消息的不丢失呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;正常来说，订阅者程序关闭后，消息会在发送者队列中堆积，等待订阅者下次订阅消费，所以未接收的消息是不会丢失的。唯一可能丢失的消息，就是在关闭的一瞬间，已经从队列中取出但还没有处理完毕的消息。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;因此我们需要一套平滑关闭的机制，保证在重启的时候，消息可以正常处理完成。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;2.问题分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;平滑关闭的思路如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;在关闭程序时，首先关闭消息订阅，这个时候消息都在发送者队列中&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭本地消息处理线程池（等待本地线程池中的消息处理完毕）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;程序退出&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;关闭消息订阅：一般消息队列的客户端都提供关闭连接的方法，具体可以自行查看api&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;关闭线程池：Java的ThreadPoolExecutor线程池提供shutdown()和shutdownNow()两个方法，区别是前者会等待线程池中的消息都处理完毕，后者直接停止线程的执行并返回list集合。因为我们需要使用shutdown()方法进行关闭，并通过isTerminated()，方法判断线程池是否已经关闭.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;那么问题又来了，我们如何通知到程序，需要执行关闭操作呢?&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在Linux中，我们可以用kill -9 pid关闭进程，除了-9之外，我们可以通过 kill -l查看kill 命令的其它信号量，比如使用 12) SIGUSR2 信号量&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们可以在Java程序启动时，注册对应的信号量，对信号量进行监听，在收到对应的kill操作时，执行相关的业务操作。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;伪代码如下&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;//注册linux kill信号量  kill -12&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Signal sig = new Signal("USR2");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Signal.handle(sig, new SignalHandler() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    @Override&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void handle(Signal signal) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        //关闭订阅者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        //关闭线程池&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        //退出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面通过一个demo模拟相关逻辑操作&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;首先模拟一个生产者，每秒生产5个消息&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;然后模拟一个订阅者，收到消息后交给线程池进行处理，线程池固定4个线程，每个消息处理时间1秒，这样线程池每秒会积压1个消息。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.lujianing.demo;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import sun.misc.Signal;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import sun.misc.SignalHandler;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.util.concurrent.*;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;/**&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; * @author lujianing01@58.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; * @Description:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; * @date 2016/11/14&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; */&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class MsgClient {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    //模拟消息队列订阅者 同时4个线程处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static final ThreadPoolExecutor THREAD_POOL = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    //模拟消息队列生产者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static final ScheduledExecutorService SCHEDULED_EXECUTOR_SERVICE = Executors.newSingleThreadScheduledExecutor();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    //用于判断是否关闭订阅&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static volatile boolean isClose = false;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args) throws InterruptedException {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        BlockingQueue &lt;string&gt; queue = new ArrayBlockingQueue&lt;string&gt;(100);&lt;/string&gt;&lt;/string&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        producer(queue);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        consumer(queue);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    //模拟消息队列生产者&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static void producer(final BlockingQueue  queue){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        //每200毫秒向队列中放入一个消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        SCHEDULED_EXECUTOR_SERVICE.scheduleAtFixedRate(new Runnable() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            public void run() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                queue.offer("");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }, 0L, 200L, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    //模拟消息队列消费者 生产者每秒生产5个   消费者4个线程消费1个1秒  每秒积压1个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static void consumer(final BlockingQueue queue) throws InterruptedException {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        while (!isClose){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            getPoolBacklogSize();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            //从队列中拿到消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            final String msg = (String)queue.take();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            //放入线程池处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            if(!THREAD_POOL.isShutdown()) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                THREAD_POOL.execute(new Runnable() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    public void run() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        try {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            //System.out.println(msg);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            TimeUnit.MILLISECONDS.sleep(1000L);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        } catch (InterruptedException e) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            e.printStackTrace();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    //查看线程池堆积消息个数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static long getPoolBacklogSize(){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        long backlog = THREAD_POOL.getTaskCount()- THREAD_POOL.getCompletedTaskCount();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println(String.format("[%s]THREAD_POOL backlog:%s",System.currentTimeMillis(),backlog));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return backlog;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    static {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        String osName = System.getProperty("os.name").toLowerCase();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        if(osName != null &amp;amp;&amp;amp; osName.indexOf("window") == -1) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            //注册linux kill信号量  kill -12&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            Signal sig = new Signal("USR2");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            Signal.handle(sig, new SignalHandler() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                @Override&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                public void handle(Signal signal) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    System.out.println("收到kill消息，执行关闭操作");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    //关闭订阅消费&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    isClose = true;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    //关闭线程池，等待线程池积压消息处理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    THREAD_POOL.shutdown();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    //判断线程池是否关闭&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    while (!THREAD_POOL.isTerminated()) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        try {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            //每200毫秒 判断线程池积压数量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            getPoolBacklogSize();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            TimeUnit.MILLISECONDS.sleep(200L);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        } catch (InterruptedException e) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                            e.printStackTrace();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    System.out.println("订阅者关闭，线程池处理完毕");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    System.exit(0);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            });&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当我们在服务上运行时，通过控制台可以看到相关的输出信息，demo中输出了线程池的积压消息个数&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;java -cp /home/work/lujianing/msg-queue-client/* com.lujianing.demo.MsgClient&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;另打开一个终端，通过ps命令查看进程号，或者通过nohup启动Java进程拿到进程id&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;ps -fe|grep MsgClient&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;table cellpadding="0" cellspacing="0" height="NaN" width="620"&gt;&lt;tbody style=" border-width: 0px !important; border-style: initial !important; border-color: initial !important; border-radius: 0px !important; background: none !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.1em !important; outline: 0px !important; overflow: visible !important;  right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important; "&gt;&lt;tr style=" border-width: 0px !important; border-style: initial !important; border-color: initial !important; border-radius: 0px !important; background: none !important; bottom: auto !important; float: none !important; height: auto !important; left: auto !important; line-height: 1.1em !important; outline: 0px !important; overflow: visible !important;  right: auto !important; top: auto !important; vertical-align: baseline !important; width: auto !important; box-sizing: content-box !important; min-height: auto !important; "&gt;&lt;td class="code" height="NaN" style=" border-width: 0px !important; border-style: initial !important; border-color: initial !important; padding: 0px !important; vertical-align: baseline !important; border-radius: 0px !important; background: none !important; bottom: auto !important; float: none !important; left: auto !important; line-height: 1.1em !important; outline: 0px !important; overflow: visible !important;  right: auto !important; top: auto !important; box-sizing: content-box !important; min-height: auto !important; " width="591"&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p style=" border-width: 0px; border-style: initial; border-color: initial; margin-bottom: 20px; font-size: 14px ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="" data-ratio="0.15521064301552107" data-type="png" data-w="902" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KP5oqznt7RtNcKPPQ4IUrCFcAiazSEt5u1uMxm9Ae6YyyYSV2IdC89Tg/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle;" title="在这里输入图片标题"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当我们执行kill -12 pid的时候 可以看到关闭业务逻辑&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="1.1344743276283618" data-type="png" data-w="409" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxZMmFicmnglQicJ064JGtn9KicjY63ZL5RTJQwDMhh0k1JgZs2tZz1eCKtu5anwQqGtvcJpX81icnUXw/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="在这里输入图片标题"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;3.问题总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在部门的实际业务中，消息队列的消息量还是挺大的，某些业务高峰时每秒有几百的消息量，因此对消息的处理要保证速度，避免消息积压，也可以通过负载解决单个订阅节点的压力。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在某些业务场景中，对消息的完整性要求不那么高，那么就不用考虑重启时的一点损耗。反之，就需要好好思考和设计了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;ps:以后会恢复写博客的习惯，争取每周都更新，如有兴趣，欢迎关注&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;2016-11-17补充&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;ThreadPoolExecutor的getQueue().size()方法，返回的为线程池队列中积压的消息数&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;getTaskCount() - getCompletedTaskCount()，返回的为线程池队列积压的和正在处理中的消息数&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;2016-11-19补充&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;感谢 @纳兰清风 的提醒&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Java中可以通过调用Runtime.getRuntime().addShutdownHook()方法，在Jvm退出时触发回调&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;kill -15 pid 可以触发调用对应的钩子方法&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;今天看重启脚本中确实也有 kill -15的命令 但是不知道两者是有关系的&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;2016-11-20补充&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;kill -1 pid 和 kill -2 pid 都能触发钩子方法&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;SIGTERM,SIGINT,SIGHUP三种信号都会触发shutdownhook&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1424007825838</guid></item><item><title>如何防止单例模式被 JAVA 反射攻击</title><link>http://chuansong.me/n/1414224925045</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：朱小厮&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/u013256816/article/details/50525335&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="46eccc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;单例模式相信大家都知道，用过的人不在少数。之前写过一篇博文《singleton模式四种线程安全的实现》（参见：http://blog.csdn.NET/u013256816/article/details/50427061），讲诉了单例模式的四种写法，并指出占位符模式的写法比较ok，详见如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.effective.singleton;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class Elvis  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static boolean flag = false;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private Elvis(){  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private  static class SingletonHolder{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        private static final Elvis INSTANCE = new Elvis();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static Elvis getInstance()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return SingletonHolder.INSTANCE;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void doSomethingElse()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;但这都是基于一个条件：确保不会通过反射机制调用私有的构造器。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这里举个例子，通过JAVA的反射机制来“攻击”单例模式：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.effective.singleton;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.lang.reflect.Constructor;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.lang.reflect.InvocationTargetException;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class ElvisReflectAttack  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Class&lt;? ?&gt; classType = Elvis.class;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Constructor&lt;? ?&gt; c = classType.getDeclaredConstructor(null);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        c.setAccessible(true);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Elvis e1 = (Elvis)c.newInstance();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Elvis e2 = Elvis.getInstance();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println(e1==e2);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行结果：false&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以看到，通过反射获取构造函数，然后调用setAccessible(true)就可以调用私有的构造函数，所有e1和e2是两个不同的对象。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;经修改后：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.effective.singleton;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class ElvisModified  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static boolean flag = false;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private ElvisModified(){  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        synchronized(ElvisModified.class)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            if(flag == false)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                flag = !flag;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            else &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                throw new RuntimeException("单例模式被侵犯！");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private  static class SingletonHolder{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        private static final ElvisModified INSTANCE = new ElvisModified();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static ElvisModified getInstance()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return SingletonHolder.INSTANCE;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void doSomethingElse()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;测试代码：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;package com.effective.singleton;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;import java.lang.reflect.Constructor;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;public class ElvisModifiedReflectAttack  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;        try &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            Class&lt;elvismodified&gt; classType = ElvisModified.class;  &lt;/elvismodified&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            Constructor&lt;elvismodified&gt; c = classType.getDeclaredConstructor(null);  &lt;/elvismodified&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            c.setAccessible(true);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            ElvisModified e1 = (ElvisModified)c.newInstance();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            ElvisModified e2 = ElvisModified.getInstance();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            System.out.println(e1==e2);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;        catch (Exception e)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;            e.printStackTrace();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 14px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Exception in thread "main" java.lang.ExceptionInInitializerError  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.effective.singleton.ElvisModified.getInstance(ElvisModified.java:27)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.effective.singleton.ElvisModifiedReflectAttack.main(ElvisModifiedReflectAttack.java:17)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Caused by: java.lang.RuntimeException: 单例模式被侵犯！  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.effective.singleton.ElvisModified.&lt;init&gt;(ElvisModified.java:16)  &lt;/init&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.effective.singleton.ElvisModified.&lt;init&gt;(ElvisModified.java:7)  &lt;/init&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.effective.singleton.ElvisModified$SingletonHolder.&lt;clinit&gt;(ElvisModified.java:22)  &lt;/clinit&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    ... 2 more&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以看到，成功的阻止了单例模式被破坏。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;从JDK1.5开始，实现Singleton还有新的写法，只需编写一个包含单个元素的枚举类型。推荐写法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.effective.singleton;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public enum SingletonClass  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    INSTANCE;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void test()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println("The Test!");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;测试代码：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.effective;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.lang.reflect.Constructor;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.lang.reflect.InvocationTargetException;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import com.effective.singleton.SingletonClass;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class TestMain  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Class&lt;singletonclass&gt; classType = SingletonClass.class;  &lt;/singletonclass&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Constructor&lt;singletonclass&gt; c = (Constructor&lt;singletonclass&gt;) classType.getDeclaredConstructor();  &lt;/singletonclass&gt;&lt;/singletonclass&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        c.setAccessible(true);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        c.newInstance();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Exception in thread "main" java.lang.NoSuchMethodException: com.effective.singleton.SingletonClass.&lt;init&gt;()  &lt;/init&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at java.lang.Class.getConstructor0(Unknown Source)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at java.lang.Class.getDeclaredConstructor(Unknown Source)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.effective.TestMain.main(TestMain.java:22)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;由此可见这种写法也可以防止单例模式被“攻击”。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;而且这种写法也可以防止序列化破坏单例模式，具体不在举例了，有关序列化以及单例模式被序列化破坏可以参考博文《JAVA序列化》（链接：http://blog.csdn.net/u013256816/article/details/50474678）。&lt;/p&gt;&lt;p&gt;单元素的枚举类型已经成为实现Singleton模式的最佳方法。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1414224925045</guid></item><item><title>Java 虚拟机 JVM 局部变量表实战</title><link>http://chuansong.me/n/1414225025040</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：分享牛&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/qq_30739519/article/details/51043512&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="e6eccc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Java局部变量表是栈帧重要组中部分之一。他主要保存函数的参数以及局部的变量信息。局部变量表中的变量作用域是当前调用的函数。函数调用结束后，随着函数栈帧的销毁。局部变量表也会随之销毁，释放空间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;由于局部变量表存在栈帧中。所以，如果函数参数和局部变量比较多，会使的局部变量表膨胀，每一次调用会占用更多的栈空间。最终结局就是栈空间内存一定的情况下调用的次数减少。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;1.1.1. 局部变量表变量影响&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面的代码演示在栈空间内存一定的情况下，参数以及局部变量的大小对函数调用次数的影响。第一个函数recursion()不包含任何的参数和局部变量,第二个函数recursion()包含3个参数和4个局部变量，因此我们也可以算出局部变量表中包含了13个变量信息。第一个局部变量表拥有更深的调用层次。代码如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;private static int count=0;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public static void recursion(int a,int b,int c){  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;long l1=12;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;short sl=1;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;byte b1=1;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;String s="1";  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println("count="+count);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;count++;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;recursion(1,2,3);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public static void recursion(){  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println("count="+count);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;count++;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;recursion();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用jvm参数-Xss128K执行上面第一个无参的recursion()函数，输出结果如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;count=4495 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Exception in thread "main" java.lang.StackOverflowError  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用jvm参数-Xss128K执行上面第二个个有参的recursion()函数，输出结果如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;count=3865 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Exception in thread "main" java.lang.StackOverflowError  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;at sun.nio.cs.UTF_8$Encoder.encodeArrayLoop(UTF_8.java:564)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:619)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以得出结论：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在同等的栈容量下，局部变量少的函数可以支持更深的函数调用。调用次数也就越多。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如何证明结论是正确的呢？在这里我们借助jclasslib工具来查看局部变量表的局部变量信息。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下图显示了无参的recursion()函数最大的局部变量表大小为0个字。有参的recursion()函数最大的局部变量表大小为8个字。在这里说明一下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;int、short、byte、对象引用等占用一个字。long和double在局部变量中需要占用2个字。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;(字 一个字在32位计算机中为4个字节的长度)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们来算一下recursion(1,2,3);方法局部变量表的大小。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;三个参数为int 所以 是3&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;long l1=12; 2&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;short sl=1; 1&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;byte b1=1; 1&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;String s=”1″; 1&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以说 一共是8个字。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="color: rgb(61, 167, 66);"&gt;需要强调的一点是这里说的局部变量表指的是java栈空间的一部分，不要跟下面说的classs字节码中的局部变量表混淆。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.7117117117117117" data-type="png" data-w="555" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQw8qRMH11KPibndfG2IsvYXbxyMibLgmWFn788NTKdYeibEcvibibeKp9ClW8bCA3YnKCKmYUerXnFBZPA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面展示class字节码中的局部变量表的内容：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.4523281596452328" data-type="png" data-w="902" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQw8qRMH11KPibndfG2IsvYXbHjvt2ljX8zhNFPXDCviczMPCSved0iaE01ibUgPTdmXRwsaQ7ztOT9T3g/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;从图中看以看出来一些信息：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在Class文件的局部变量表定义中，显示了每一个局部变量的作用范围、所在槽位的索引信息(index列信息)，&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;变量的名称(name列)和数据类型信息(descriptor列)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;数据类型信息映射：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;I—int类型&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;D–double类型&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;B-byte类型&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Ljava/lange/Integer –Integer类型&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Ljava/lange/String–String类型&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;S–short类型&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;栈帧中的局部变量的槽位是可以重复使用的。如果一个声明的变量过了其作用域，那么其作用域之后申请的变量有可能复用过期的局部变量的槽位，从而能够达到节省资源目的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;1.1.2. 局部变量表槽位的复用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面得代码显示了局部变量表槽位的复用。localVar1()函数中，局部变量a和b得范围都是到了函数的末尾所以b是没有办法复用a的卡槽所在的位置。localVar2()函数中，局部变量a在}之后不在有效了，所以b是可以复用a的卡槽的位置都是int类型所以是1个字。程序如下所示：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public void localVar1(){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;int a=0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println(a);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;int b=0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public void localVar2(){&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;int a=0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println(a);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;int b=0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用jclasslib工具来查看局部变量表的局部变量localVar1()信息如下图：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.5438247011952191" data-type="png" data-w="502" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQw8qRMH11KPibndfG2IsvYXbIxcoyJTMNhiaoRdlnlIH5h3iaIWk2ibMjn8VsvaGDiaReFC5yUDQicbyqQw/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.20697167755991286" data-type="png" data-w="918" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQw8qRMH11KPibndfG2IsvYXb1r2icZjgd0v6bQsmsHaGx9VnJyhHYIiaFyB7fvRrTv8KvGibjSYLYR0ww/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;该函数最大的局部变量大小3个字，卡槽0位为thsi引用(实例方法的第一个局部变量都是this)，第一个卡槽位变量为a,第二个卡槽位变量为b,每个变量是1个字所以一共是三个字。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;使用jclasslib工具来查看局部变量表的局部变量localVar2()信息如下图：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.5572519083969466" data-type="png" data-w="524" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQw8qRMH11KPibndfG2IsvYXbTWYFtkwgL36mPbHCTI6icocibZkQhA8Vk3H9AZjwIP8hgVIk88agFiaicw/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.26584234930448225" data-type="png" data-w="647" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQw8qRMH11KPibndfG2IsvYXbrRm7KFS0SFIcVXhGKv8H3rmMCaQlwFib4fNqeQNxoImOO8pQxkPXfsA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;该函数最大的局部变量大小2个字，卡槽0位为thsi引用(实例方法的第一个局部变量都是this)，第一个卡槽位变量为a,第二个卡槽位变量为b,每个变量是1个字 但是b变量复用了a卡槽位所以一共是2个字。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;局部变量表也是作为垃圾回收gc的重要参考点，只要被局部变量表中直接或者间接引用的对象都不会被回收。所以必须要理解局部变量表才能理解gc回收机制。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面的主要讲解说明局部变量对垃圾回收的影响。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;1.1.3. 局部变量对垃圾回收的影响&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;程序代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;jvm参数-XX:+PrintGC参数 垃圾回收前后堆得大小&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JvmTestLocalVarGc t=new JvmTestLocalVarGc();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;t.localvarGc1();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;结果输出：[Full GC 3875K-&amp;gt;3546K(15872K), 0.0050719 secs]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在申请空间后，立即调用GC垃圾回收，很明显，由于byte被b强引用所以无法回收这块空间。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JvmTestLocalVarGc t=new JvmTestLocalVarGc();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;t.localvarGc2();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;结果输出：[Full GC 3875K-&amp;gt;474K(15872K), 0.0036066 secs]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在垃圾回收前，现将b设置为null，使byte数组拾取引用，所以GC后byte数组被直接垃圾回收了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JvmTestLocalVarGc t=new JvmTestLocalVarGc();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;t.localvarGc3();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;结果输出：[Full GC 3875K-&amp;gt;3546K(15872K), 0.0069622 secs]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在进行垃圾回收前，先使局部变量b实现，虽然b离开了作用域，但是变量b亦然存放在局部变量表中。并且指向byte数组，故byte数组亦然没有被回收。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JvmTestLocalVarGc t=new JvmTestLocalVarGc();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;t.localvarGc4();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;结果输出：[Full GC 3875K-&amp;gt;474K(15872K), 0.0037666 secs]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在垃圾回收前，不仅是b失效了，c复用了变量b的字，由于b被销毁，所以byte数组被销毁了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JvmTestLocalVarGc t=new JvmTestLocalVarGc();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;t.localvarGc5();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;结果输出：[Full GC 3875K-&amp;gt;3546K(15872K), 0.0054367 secs]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;[Full GC 3546K-&amp;gt;474K(15936K), 0.0036164 secs]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于localvarGc5()调用localvarGc1()方法，很明显localvarGc1()中没有回收byte数组，但在其返回后他的栈帧被销毁了，自然栈帧中所有的局部变量也没销毁了,容器没了，值当然也不存在了嘛。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以byte数组失去饮用。在localvarGc5()中被回收了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1414225025040</guid></item><item><title>线程及同步的性能 - 线程池 / ThreadPoolExecutors / ForkJoinPool</title><link>http://chuansong.me/n/1405749625073</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：dm_vincent&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/dm_vincent/article/details/39505977&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="sbQccc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;线程池和ThreadPoolExecutors&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;虽然在程序中可以直接使用Thread类型来进行线程操作，但是更多的情况是使用线程池，尤其是在Java EE应用服务器中，一般会使用若干个线程池来处理来自客户端的请求。Java中对于线程池的支持，来自ThreadPoolExecutor。一些应用服务器也确实是使用的ThreadPoolExecutor来实现线程池。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于线程池的性能调优，最重要的参数就是线程池的大小。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于任何线程池而言，它们的工作方式几乎都是相同的：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;任务被投放到一个队列中(队列的数量不定)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;线程从队列中取得任务并执行&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;线程完成任务后，继续尝试从队列中取得任务，如果队列为空，那么线程进入等待状态&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;线程池往往拥有最小和最大线程数：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;最小线程数&lt;/strong&gt;，即当任务队列为空时，线程池中最少需要保持的线程数量，这样做是考虑到创建线程是一个相对耗费资源的操作，应当尽可能地避免，当有新任务被投入队列时，总会有线程能够立即对它进行处理。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;最大线程数&lt;/strong&gt;，当需要处理的任务过多时，线程池能够拥有的最大线程数。这样是为了保证不会有过多的线程被创建出来，因为线程的运行需要依赖于CPU资源和其它各种资源，当线程过多时，反而会降低性能。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;在ThreadPoolExecutor和其相关的类型中，最小线程数被称为线程池核心规模(Core Pool Size)，在其它Java应用服务器的实现中，这个数量也许被称为最小线程数(MinThreads)，但是它们的概念是相同的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;但是在对线程池进行规模变更(Resizing)的时候，ThreadPoolExecutor和其它线程池的实现也许存在的很大的差别。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;一个最简单的情况是：当有新任务需要被执行，且当前所有的线程都被占用时，ThreadPoolExecutor和其它实现通常都会新创建一个线程来执行这个新任务(直到达到了最大线程数)。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;设置最大线程数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;最合适的最大线程数该怎么确定，依赖以下两个方面：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;任务的特征&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;计算机的硬件情况&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;为了方便讨论，下面假设JVM有4个可用的CPU。那么任务也很明确，就是要最大程度地“压榨”它们的资源，千方百计的提高CPU的利用率。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;那么，最大线程数最少需要被设置成4，因为有4个可用的CPU，意味着最多能够并行地执行4个任务。当然，垃圾回收(Garbage Collection)在这个过程中也会造成一些影响，但是它们往往不需要使用整个CPU。一个例外是，当使用了CMS或者G1垃圾回收算法时，需要有足够的CPU资源进行垃圾回收。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;那么是否有必要将线程数量设置的更大呢？这就取决于任务的特征了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;假设当任务是计算密集型的，意味着任务不需要执行IO操作，例如读取数据库，读取文件等，因此它们不涉及到同步的问题，任务之间完全是独立的。比如使用一个批处理程序读取Mock数据源的数据，测试在不线程池拥有不同线程数量时的性能，得到下表：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;img data-ratio="0.3146067415730337" data-s="300,640" data-type="png" data-w="1246" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36FtjvO1tjKCNL7lOaNjjFVibCTof0zj7mH4NSxoWGncs2jb6ha5fYF7oIruQ/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;从上面中得到一些结论：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;当线程数为4时，达到最优性能，再增加线程数量时并没有更好的性能，因为此时CPU的利用率已经达到了最高，在增加线程只会增加线程之间争夺CPU资源的行为，因此反而降低了性能。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;即使在CPU利用率达到最高时，基线百分比也不是理想中的25%，这是因为虽然在程序运行过程中，CPU资源并不是只被应用程序线程独享的，一些后台线程有时也会需要CPU资源，比如GC线程和系统的一些线程等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;当计算是通过Servlet触发的时候，性能数据是下面这个样子的(Load Generator会同时发送20个请求)：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;img data-ratio="0.31259968102073366" data-s="300,640" data-type="png" data-w="1254" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36FtjvMaKc3AXMN2Lr6oIJNjY9egtUdriadnZDXDClicfsBUhgHlicvrQvu5ENQ/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;从上表中可以得到的结论：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;在线程数量为4时，性能最优。因为此任务的类型是计算密集型的，只有4个CPU，因此线程数量为4时，达到最优情况。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;随着线程数量逐渐增加，性能下降，因为线程之间会互相争夺CPU资源，造成频繁切换线程执行上下文环境，而这些切换只会浪费CPU资源。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;性能下降的速度并不明显，这也是因为任务类型是计算密集型的缘故，如果性能瓶颈不是CPU提供的计算资源，而是外部的资源，如数据库，文件操作等，那么增加线程数量带来的性能下降也许会更加明显。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;下面，从Client的角度考虑一下问题，并发Client的数量对于Server的响应时间会有什么影响呢？还是同样地环境，当并发Client数量逐渐增加时，响应时间会如下发生变化：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;img data-ratio="0.472" data-s="300,640" data-type="png" data-w="1250" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36FtjvcAYDC7nkq8HN4LSibQ4XSt5EuYx4bxU2BXBb1gS4WytFMrqzQBk8yrg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;因为任务类型是计算密集型的，当并发Client数量时1，2，4时，平均响应时间都是最优的，然而当出现多余4个Client时，性能会随着Client的增加发生显著地下降。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;当Client数量增加时，你也许会想通过增加服务端线程池的线程数量来提高性能，可是在CPU密集型任务的情况下，这么做只会降低性能。因为系统的瓶颈就是CPU资源，冒然增加线程池的线程数量只会让对于这种资源的竞争更加激烈。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;所以，在面对性能方面的问题时。第一步永远是了解系统的瓶颈在哪里，这样才能够有的放矢。如果冒然进行所谓的“调优”，让对瓶颈资源的竞争更加激烈，那么带来的只会是性能的进一步下降。相反，如果让对瓶颈资源的竞争变的缓和，那么性能通常则会提高。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;在上面的场景中，如果从ThreadPoolExecutor的角度进行考虑，那么在任务队列中一直会有任务处于挂起(Pending)的状态(因为Client的每个请求对应的就是一个任务)，而所有的可用线程都在工作，CPU正在满负荷运转。这个时候添加线程池的线程数量，让这些添加的线程领取一些挂起的任务，会发生什么事情呢？这时带来的只会是线程之间对于CPU资源的争夺更加激烈，降低了性能。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;设置最小线程数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;设置了最大线程数之后，还需要设置最小线程数。对于绝大部分场景，将它设置的和最大线程数相等就可以了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;将最小线程数设置的小于最大线程数的初衷是为了节省资源，因为每多创建一个线程都会耗费一定量的资源，尤其是线程栈所需要的资源。但是在一个系统中，针对硬件资源以及任务特点选定了最大线程数之后，就表示这个系统总是会利用这些线程的，那么还不如在一开始就让线程池把需要的线程准备好。然而，把最小线程数设置的小于最大线程数所带来的影响也是非常小的，一般都不会察觉到有什么不同。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;在批处理程序中，最小线程数是否等于最大线程数并不重要。因为最后线程总是需要被创建出来的，所以程序的运行时间应该几乎相同。对于服务器程序而言，影响也不大，但是一般而言，线程池中的线程在“热身”阶段就应该被创建出来，所以这也是为什么建议将最小线程数设置的等于最大线程数的原因。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;在一些场景中，也需要要设置一个不同的最小线程数。比如当一个系统最大需要同时处理2000个任务，而平均任务数量只是20个情况下，就需要将最小线程数设置成20，而不是等于其最大线程数2000。此时如果还是将最小线程数设置的等于最大线程数的话，那么闲置线程(Idle Thread)占用的资源就比较可观了，尤其是当使用了ThreadLocal类型的变量时。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;线程池任务数量(Thread Pool Task Sizes)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;线程池有一个列表或者队列的数据结构来存放需要被执行的任务。显然，在某些情况下，任务数量的增长速度会大于其被执行的速度。如果这个任务代表的是一个来自Client的请求，那么也就意味着该Client会等待比较长的时间。显然这是不可接受的，尤其对于提供Web服务的服务器程序而言。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;所以，线程池会有机制来限制列表/队列中任务的数量。但是，和设置最大线程数一样，并没有一个放之四海而皆准的最优任务数量。这还是要取决于具体的任务类型和不断的进行性能测试。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;对于ThreadPoolExecutor而言，当任务数量达到最大时，再尝试增加新的任务就会失败。ThreadPoolExecutor有一个rejectedExecution方法用来拒绝该任务。这会导致应用服务器返回一个HTTP状态码500，当然这种信息最好以更友好的方式传达给Client，比如解释一下为什么你的请求被拒绝了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;定制ThreadPoolExecutor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;线程池在同时满足以下三个条件时，就会创建一个新的线程：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;有任务需要被执行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;当前线程池中所有的线程都处于工作状态&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;当前线程池的线程数没有达到最大线程数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;至于线程池会如何创建这个新的线程，则是根据任务队列的种类：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;任务队列是 SynchronousQueue 这个队列的特点是，它并不能放置任何任务在其队列中，当有任务被提交时，使用SynchronousQueue的线程池会立即为该任务创建一个线程(如果线程数量没有达到最大时，如果达到了最大，那么该任务会被拒绝)。这种队列适合于当任务数量较小时采用。也就是说，在使用这种队列时，未被执行的任务没有一个容器来暂时储存。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;任务队列是 无限队列(Unbound Queue) 无界限的队列可以是诸如LinkedBlockingQueue这种类型，在这种情况下，任何被提交的任务都不会被拒绝。但是线程池会忽略最大线程数这一参数，意味着线程池的最大线程数就变成了设置的最小线程数。所以在使用这种队列时，通常会将最大线程数设置的和最小线程数相等。这就相当于使用了一个固定了线程数量的线程池。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;任务队列是 有限队列(Bounded Queue) 当使用的队列是诸如ArrayBlockingQueue这种有限队列的时候，来决定什么时候创建新线程的算法就相对复杂一些了。比如，最小线程数是4，最大线程数是8，任务队列最多能够容纳10个任务。在这种情况下，当任务逐渐被添加到队列中，直到队列被占满(10个任务)，此时线程池中的工作线程仍然只有4个，即最小线程数。只有当仍然有任务希望被放置到队列中的时候，线程池才会新创建一个线程并从队列头部拿走一个任务，以腾出位置来容纳这个最新被提交的任务。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;关于如何定制ThreadPoolExecutor，遵循KISS原则(Keep It Simple, Stupid)就好了。比如将最大线程数和最小线程数设置的相等，然后根据情况选择有限队列或者无限队列。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;线程池是对象池的一个有用的例子，它能够节省在创建它们时候的资源开销。并且线程池对系统中的线程数量也起到了很好的限制作用。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;线程池中的线程数量必须仔细的设置，否则冒然增加线程数量只会带来性能的下降。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p style="text-align: justify;"&gt;在定制ThreadPoolExecutor时，遵循KISS原则，通常情况下会提供最好的性能。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;ForkJoinPool&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;在Java 7中引入了一种新的线程池：ForkJoinPool。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;比如，我们需要统计一个double数组中小于0.5的元素的个数，那么可以使用ForkJoinPool进行实现如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class ForkJoinTest {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private double[] d;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private class ForkJoinTask extends RecursiveTask&lt;integer&gt; {&lt;/integer&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        private int first;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        private int last;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        public ForkJoinTask(int first, int last) {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            this.first = first;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            this.last = last;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        protected Integer compute() {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            int subCount;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            if (last - first &amp;lt; 10) {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                subCount = 0;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                for (int i = first; i &amp;lt;= last; i++) {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    if (d[i] &amp;lt; 0.5)&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        subCount++;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            else {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                int mid = (first + last) &amp;gt;&amp;gt;&amp;gt; 1;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                ForkJoinTask left = new ForkJoinTask(first, mid);&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                left.fork();&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                ForkJoinTask right = new ForkJoinTask(mid + 1, last);&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                right.fork();&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                subCount = left.join();&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                subCount += right.join();&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            return subCount;&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        d = createArrayOfRandomDoubles();&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        int n = new ForkJoinPool().invoke(new ForkJoinTask(0, 9999999));&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println("Found " + n + " values");&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;以上的关键是fork()和join()方法。在ForkJoinPool使用的线程中，会使用一个内部队列来对需要执行的任务以及子任务进行操作来保证它们的执行顺序。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;当然，在上面的例子中，也可以不使用分治法，因为任务之间的独立性，可以将整个数组划分为几个区域，然后使用ThreadPoolExecutor来解决，这种办法不会创建数量庞大的子任务。代码如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class ThreadPoolTest {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private double[] d;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private class ThreadPoolExecutorTask implements Callable&lt;integer&gt; {&lt;/integer&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        private int first;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        private int last;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        public ThreadPoolExecutorTask(int first, int last) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            this.first = first;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            this.last = last;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        public Integer call() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            int subCount = 0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            for (int i = first; i &amp;lt;= last; i++) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                if (d[i] &amp;lt; 0.5) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    subCount++;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            return subCount;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        d = createArrayOfRandomDoubles();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        ThreadPoolExecutor tpe = new ThreadPoolExecutor(4, 4, Long.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingQueue());&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Future[] f = new Future[4];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        int size = d.length / 4;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        for (int i = 0; i &amp;lt; 3; i++) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            f[i] = tpe.submit(new ThreadPoolExecutorTask(i * size, (i + 1) * size - 1);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        f[3] = tpe.submit(new ThreadPoolExecutorTask(3 * size, d.length - 1);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        int n = 0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        for (int i = 0; i &amp;lt; 4; i++) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            n += f.get();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println("Found " + n + " values");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在分别使用ForkJoinPool和ThreadPoolExecutor时，它们处理这个问题的时间如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img data-ratio="0.1634920634920635" data-s="300,640" data-type="png" data-w="1260" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36FtjvFD7AQNyDr57I6MdPzJkAKxFHxzHbz1A5zS61H68sUPOxAA9nrAGzWg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对执行过程中的GC同样也进行了监控，发现在使用ForkJoinPool时，总的GC时间花去了1.2s，而ThreadPoolExecutor并没有触发任何的GC操作。这是因为在ForkJoinPool的运行过程中，会创建大量的子任务。而当他们执行完毕之后，会被垃圾回收。反之，ThreadPoolExecutor则不会创建任何的子任务，因此不会导致任何的GC操作。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;ForkJoinPool的另外一个特性是它能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以通过以下的代码来测试ForkJoinPool的Work Stealing特性：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;for (int i = first; i &amp;lt;= last; i++) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    if (d[i] &amp;lt; 0.5) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        subCount++;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    for (int j = 0; j &amp;lt; d.length - i; j++) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        for (int k = 0; k &amp;lt; 100; k++) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            dummy = j * k + i; // dummy is volatile, so multiple writes occur&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            d[i] = dummy;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;因为里层的循环次数(j)是依赖于外层的i的值的，所以这段代码的执行时间依赖于i的值。当i = 0时，执行时间最长，而i = last时执行时间最短。也就意味着任务的工作量是不一样的，当i的值较小时，任务的工作量大，随着i逐渐增加，任务的工作量变小。因此这是一个典型的任务负载不均衡的场景。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这时，选择ThreadPoolExecutor就不合适了，因为它其中的线程并不会关注每个任务之间任务量的差异。当执行任务量最小的任务的线程执行完毕后，它就会处于空闲的状态(Idle)，等待任务量最大的任务执行完毕。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;而ForkJoinPool的情况就不同了，即使任务的工作量有差别，当某个线程在执行工作量大的任务时，其他的空闲线程会帮助它完成剩下的任务。因此，提高了线程的利用率，从而提高了整体性能。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这两种线程池对于任务工作量不均衡时的执行时间：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img data-ratio="0.16108452950558214" data-s="300,640" data-type="png" data-w="1254" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36Ftjv0llmlMObTrZa5PWWntQQ9gia8mlon2oZQgUmjIZianibhcaOfRQvamm3Q/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;注意到当线程数量为1时，两者的执行时间差异并不明显。这是因为总的计算量是相同的，而ForkJoinPool慢的那一秒多是因为它创建了非常多的任务，同时也导致了GC的工作量增加。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当线程数量增加到4时，执行时间的区别就较大了，ForkJoinPool的性能比ThreadPoolExecutor好将近50%，可见Work Stealing在应对任务量不均衡的情况下，能够保证资源的利用率。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以一个结论就是：当任务的任务量均衡时，选择ThreadPoolExecutor往往更好，反之则选择ForkJoinPool。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;另外，对于ForkJoinPool，还有一个因素会影响它的性能，就是停止进行任务分割的那个阈值。比如在之前的快速排序中，当剩下的元素数量小于10的时候，就会停止子任务的创建。下表显示了在不同阈值下，ForkJoinPool的性能：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img data-ratio="0.266347687400319" data-s="300,640" data-type="png" data-w="1254" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36Ftjvq8q52sj9iaBJ2IVh4NBpe5ib1miaWUYTmPuSAO6NBT6OicjZpia8tcwNrTA/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以发现，当阈值不同时，对于性能也会有一定影响。因此，在使用ForkJoinPool时，对此阈值进行测试，使用一个最合适的值也有助于整体性能。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;自动并行化(Automatic Parallelization)&lt;/p&gt;&lt;p&gt;在Java 8中，引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，前提是使用了ForkJoinPool。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;比如下面的代码用来遍历列表中的元素并执行需要的计算：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Stream&lt;integer&gt; stream = arrayList.parallelStream();&lt;/integer&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;stream.forEach(a -&amp;gt; {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    String symbol = StockPriceUtils.makeSymbol(a);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    StockPriceHistory sph = new StockPriceHistoryImpl(symbol, startDate, endDate, entityManager);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;});&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于列表中的元素的计算都会以并行的方式执行。forEach方法会为每个元素的计算操作创建一个任务，该任务会被前文中提到的ForkJoinPool中的通用线程池处理。以上的并行计算逻辑当然也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;对于ForkJoinPool通用线程池的线程数量，通常使用默认值就可以了，即运行时计算机的处理器数量。如果需要调整线程数量，可以通过设置系统属性：-Djava.util.concurrent.ForkJoinPool.common.parallelism=N&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面的一组数据用来比较使用ThreadPoolExecutor和ForkJoinPool中的通用线程池来完成上面简单计算时的性能：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img data-ratio="0.3136" data-s="300,640" data-type="png" data-w="1250" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQxlJdrC9a3WmAHJDD36FtjvibPO9W5hGbujx2iclicuO0CiaSKpKvG1kUnB5yxVm3j5PNXp6ABopYxg1w/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;注意到当线程数为1，2，4时，性能差异的比较明显。线程数为1的ForkJoinPool通用线程池和线程数为2的ThreadPoolExecutor的性能十分接近。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;出现这种现象的原因是，forEach方法用了一些小把戏。它会将执行forEach本身的线程也作为线程池中的一个工作线程。因此，即使将ForkJoinPool的通用线程池的线程数量设置为1，实际上也会有2个工作线程。因此在使用forEach的时候，线程数为1的ForkJoinPool通用线程池和线程数为2的ThreadPoolExecutor是等价的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以当ForkJoinPool通用线程池实际需要4个工作线程时，可以将它设置成3，那么在运行时可用的工作线程就是4了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;当需要处理递归分治算法时，考虑使用ForkJoinPool。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;仔细设置不再进行任务划分的阈值，这个阈值对性能有影响。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Java 8中的一些特性会使用到ForkJoinPool中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1405749625073</guid></item><item><title>Quartz 入门详解</title><link>http://chuansong.me/n/1405749725019</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="font-size: 16px; white-space: normal; max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="font-size: 16px; white-space: normal; max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="font-size: 16px; white-space: normal; max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：文牛武人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/wenniuwuren/article/details/41483667&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="TbQccc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;入门简介：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;基本上任何公司都会用到调度这个功能， 比如我们公司需要定期执行调度生成报表， 或者比如博客什么的定时更新之类的，都可以靠Quartz来完成。正如官网所说，小到独立应用大到大型电子商务网站， Quartz都能胜任。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;Quartz体系结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;明白Quartz怎么用，首先要了解Scheduler(调度器)、Job(任务)和Trigger(触发器)这3个核心的概念。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;1. Job&lt;/span&gt;&lt;/strong&gt;： 是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务)， JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;2. JobDetail&lt;/span&gt;&lt;/strong&gt;： Quartz每次调度Job时， 都重新创建一个Job实例， 所以它不直接接受一个Job的实例，相反它接收一个Job实现类(JobDetail:描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息)，以便运行时通过newInstance()的反射机制实例化Job。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;3. Trigger&lt;/span&gt;&lt;/strong&gt;： 是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如工作日周一到周五的15：00~16：00执行调度等；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Cron表达式的格式：秒 分 时 日 月 周 年(可选)。&lt;/p&gt;&lt;p&gt;字段名                 允许的值                        允许的特殊字符&lt;/p&gt;&lt;p&gt;秒                         0-59                               , – * /&lt;/p&gt;&lt;p&gt;分                         0-59                               , – * /&lt;/p&gt;&lt;p&gt;小时                   0-23                                 , – * /&lt;/p&gt;&lt;p&gt;日                         1-31                               , – * ? / L W C&lt;/p&gt;&lt;p&gt;月                         1-12 or JAN-DEC           , – * /&lt;/p&gt;&lt;p&gt;周几                     1-7 or SUN-SAT             , – * ? / L C #      MON  FRI&lt;/p&gt;&lt;p&gt;年 (可选字段)     empty, 1970-2099            , – * /&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;“?”字符：表示不确定的值&lt;/p&gt;&lt;p&gt;“,”字符：指定数个值&lt;/p&gt;&lt;p&gt;“-”字符：指定一个值的范围&lt;/p&gt;&lt;p&gt;“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m&lt;/p&gt;&lt;p&gt;“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X&lt;/p&gt;&lt;p&gt;“W”字符：指定离给定日期最近的工作日(周一到周五)&lt;/p&gt;&lt;p&gt;“#”字符：表示该月第几个周X。6#3表示该月第3个周五&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Cron表达式范例：&lt;/p&gt;&lt;p&gt;每隔5秒执行一次：*/5 * * * * ?&lt;/p&gt;&lt;p&gt;每隔1分钟执行一次：0 */1 * * * ?&lt;/p&gt;&lt;p&gt;每天23点执行一次：0 0 23 * * ?&lt;/p&gt;&lt;p&gt;每天凌晨1点执行一次：0 0 1 * * ?&lt;/p&gt;&lt;p&gt;每月1号凌晨1点执行一次：0 0 1 1 * ?&lt;/p&gt;&lt;p&gt;每月最后一天23点执行一次：0 0 23 L * ?&lt;/p&gt;&lt;p&gt;每周星期天凌晨1点实行一次：0 0 1 ? * L&lt;/p&gt;&lt;p&gt;在26分、29分、33分执行一次：0 26,29,33 * * * ?&lt;/p&gt;&lt;p&gt;每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;4. Calendar&lt;/span&gt;&lt;/strong&gt;：org.quartz.Calendar和java.util.Calendar不同， 它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。 一个Trigger可以和多个Calendar关联， 以便排除或包含某些时间点。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。针对不同时间段类型，Quartz在org.quartz.impl.calendar包下提供了若干个Calendar的实现类，如AnnualCalendar、MonthlyCalendar、WeeklyCalendar分别针对每年、每月和每周进行定义；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;5. Scheduler&lt;/span&gt;&lt;/strong&gt;： 代表一个Quartz的独立运行容器， Trigger和JobDetail可以注册到Scheduler中， 两者在Scheduler中拥有各自的组及名称， 组及名称是Scheduler查找定位容器中某一对象的依据， Trigger的组及名称必须唯一， JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法， 允许外部通过组及名称访问和控制容器中Trigger和JobDetail。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Scheduler可以将Trigger绑定到某一JobDetail中， 这样当Trigger触发时， 对应的Job就被执行。一个Job可以对应多个Trigger， 但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(123, 12, 0);"&gt;6. ThreadPool&lt;/span&gt;&lt;/strong&gt;： Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Job有一个StatefulJob子接口，代表有状态的任务，该接口是一个没有方法的标签接口，其目的是让Quartz知道任务的类型，以便采用不同的执行方案。无状态任务在执行时拥有自己的JobDataMap拷贝，对JobDataMap的更改不会影响下次的执行。而有状态任务共享共享同一个JobDataMap实例，每次任务执行对JobDataMap所做的更改会保存下来，后面的执行可以看到这个更改，也即每次执行任务后都会对后面的执行发生影响。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;正因为这个原因，无状态的Job可以并发执行，而有状态的StatefulJob不能并发执行，这意味着如果前次的StatefulJob还没有执行完毕，下一次的任务将阻塞等待，直到前次任务执行完毕。有状态任务比无状态任务需要考虑更多的因素，程序往往拥有更高的复杂度，因此除非必要，应该尽量使用无状态的Job。&lt;/p&gt;&lt;p&gt;如果Quartz使用了数据库持久化任务调度信息，无状态的JobDataMap仅会在Scheduler注册任务时保持一次，而有状态任务对应的JobDataMap在每次执行任务后都会进行保存。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Trigger自身也可以拥有一个JobDataMap，其关联的Job可以通过JobExecutionContext#getTrigger().getJobDataMap()获取Trigger中的JobDataMap。不管是有状态还是无状态的任务，在任务执行期间对Trigger的JobDataMap所做的更改都不会进行持久，也即不会对下次的执行产生影响。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Quartz拥有完善的事件和监听体系，大部分组件都拥有事件，如任务执行前事件、任务执行后事件、触发器触发前事件、触发后事件、调度器开始事件、关闭事件等等，可以注册相应的监听器处理感兴趣的事件。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下图描述了Scheduler的内部组件结构，SchedulerContext提供Scheduler全局可见的上下文信息，每一个任务都对应一个JobDataMap，虚线表达的JobDataMap表示对应有状态的任务：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.4923747276688453" data-type="jpeg" data-w="459" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQxlJdrC9a3WmAHJDD36FtjvErDTBGM3ouzk7L8fpF3mUXy26qNG7WMcBsIYXQqjmQEvyKj2hxWibDg/0?wx_fmt=jpeg" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;废话不多说， 上代码：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;1. 最简单的Job代码(就打印Hello Quartz ！)：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.wenniuwuren.quartz;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.Job;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.JobExecutionContext;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.JobExecutionException;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class HelloQuartz  implements Job {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void execute(JobExecutionContext arg0) throws JobExecutionException {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println("Hello Quartz !");                 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }         &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;2. 设置触发器&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.wenniuwuren.quartz;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.CronScheduleBuilder;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.JobBuilder;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.JobDetail;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.Scheduler;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.SchedulerException;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.SchedulerFactory;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.SimpleScheduleBuilder;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.Trigger;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.TriggerBuilder;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import org.quartz.impl.StdSchedulerFactory;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class SchedulerTest {    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   public static void main(String[] args) throws InterruptedException {    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       //通过schedulerFactory获取一个调度器    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       SchedulerFactory schedulerfactory = new StdSchedulerFactory();    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       Scheduler scheduler=null;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       try{    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           // 通过schedulerFactory获取一个调度器    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           scheduler = schedulerfactory.getScheduler();    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            // 创建jobDetail实例，绑定Job实现类    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            // 指明job的名称，所在组的名称，以及绑定job类    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           JobDetail job = JobBuilder.newJob(HelloQuartz.class).withIdentity("JobName", "JobGroupName").build();    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            // 定义调度触发规则    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            // SimpleTrigger   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;//      Trigger trigger=TriggerBuilder.newTrigger().withIdentity("SimpleTrigger", "SimpleTriggerGroup")    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;//                    .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(3).withRepeatCount(6))    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;//                    .startNow().build();    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            //  corn表达式  每五秒执行一次  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;              Trigger trigger=TriggerBuilder.newTrigger().withIdentity("CronTrigger1", "CronTriggerGroup")    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;              .withSchedule(CronScheduleBuilder.cronSchedule("*/5 * * * * ?"))    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;              .startNow().build();     &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            // 把作业和触发器注册到任务调度中    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           scheduler.scheduleJob(job, trigger);    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           // 启动调度    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           scheduler.start();    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           Thread.sleep(10000);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           // 停止调度  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           scheduler.shutdown();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       }catch(SchedulerException e){    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;           e.printStackTrace();    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       }    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   }    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;输出(设置了sleep10秒， 故在0秒调度一次， 5秒一次， 10秒最后一次)：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.24317617866004962" data-type="jpeg" data-w="806" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQxlJdrC9a3WmAHJDD36Ftjv21VN4UVibonehGYWB9YG6Wetibakia49ROS38vf0TibUrWugEC6Fdnj6ZA/0?wx_fmt=jpeg" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1405749725019</guid></item><item><title>Intellij IDEA 一些不为人知的技巧</title><link>http://chuansong.me/n/1400972725741</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：khotyn&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：www.jianshu.com/p/364b94a664ff&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="WCYJcc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;今天又听了 Jetbrains 首席布道师 Hadi 的分享的 Intellij IDEA 使用技巧，说又是是因为之前在 QCon 听过一遍，但是这次 Hadi 带来的分享又超出了预期（很多布道师到处讲的东西都差不多），从他的这次分享中学到了不少的东西。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这篇文章的主要目的是将我觉得非常有用的东西给记录下来，一方面是对自己感受的一个整理，一方面也给其他喜欢文字而不喜欢视频的同学一个参考（推荐大家看 ATIT 的视频，Hadi 都是现场直接演示功能）。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;注意：这篇文章是基于我目前使用的 Intellij IDEA 版本，2016.3 Ultimate 来写的，快捷键是 Mac OS 10.5+。如果同学们使用其他的版本或者快捷键，请大家注意自行脑补映射，(⊙o⊙)…&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;关闭 Intellij IDEA 的 Tab 页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;为什么要关闭 Intellij IDEA 的 Tab 页呢，Tab 页放在那里，当我们每次需要找文件的时候，都先要去 Tab 页瞄一眼，看下在不在 Tab 页，如果在的话，用鼠标点一下。这种操作的效率其实非常慢，更加快速的方式是直接关闭掉 Tab 页的功能：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22609" data-ratio="0.5152439024390244" data-type="png" data-w="2624" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVudbCdnoGYdpXib05TjVRF9GlD8Dy3Ha78h2iaOerOrYzFdY6LfPz9fCA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="waBdKMFoaCxxEygUrxcQ"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;然后直接用 Command + E 来找到最近访问的文件：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a rel="attachment wp-att-22610" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 14px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-22610" data-ratio="0.8948453608247423" data-type="png" data-w="970" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVmavzX5xz0zbfM5YoHBL6EV1mrQMvSCU4abZbsN0z91OBkJWLiborr5Q/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle;" title="MBOHjJxjrlfdaLAOiGmJ"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;或者直接用 Command + Shift + E 来访问最近编辑的文件：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22611" data-ratio="0.8948453608247423" data-type="png" data-w="970" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVgGHjVJqYD3xuib72y5vU7U3h0tFJMOSpz4ic4JkJTYmwrXwdEicLhItPg/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="VJzVYjkiWjGMDwuADPmW"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;跳到特定文件夹&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Intellij IDEA 和 Eclipse 都有快速根据类名寻找类，或者根据资源名寻找资源的方式，但是如果我们想找一个文件夹，在 Intellij IDEA 里面，可以输入 /文件夹名 来跳到特定的文件夹（使用 Double Shift 快捷键），截图如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a rel="attachment wp-att-22612" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 14px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-22612" data-ratio="0.29940828402366865" data-type="png" data-w="1690" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVmmBNlRibfib5LFN2B5WsAfVnbdV18ZibSicyV873oHm8a6WudW9UWDS7icg/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle;" title="gZyzmOLUhsqmbdPoFriJ"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;快速补全行末分号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Java 中，每一个 statement 后面都得加上 ; 号，我们可以在行中任意位置使用快捷键 Command + Shift + Enter 来快速补全分号：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a rel="attachment wp-att-22613" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 14px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-22613" data-ratio="0.5866666666666667" data-type="gif" data-w="1425" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_gif/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzV5hhsYokIGOiak6XBpFdrYJzMiaYEHgXy6SsHJHaTtrksd9WU5Uq139uQ/0?wx_fmt=gif" style="border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle;" title="JNYmlAMPWqUNMLFRHnrB"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;Rest Client&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Intellij IDEA 里面内置了一个 Rest Client，大家可以通过 Command + Shift + A，然后搜索 Rest Client 来找到：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22614" data-ratio="0.8052373158756138" data-type="png" data-w="1222" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzV0iaUEbCmuqBgNMiaXVhMOcv8NGFYYqyotQniadJ1icsqyZ7ALwIACorQDg/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="XtvbsWkHzGTKORoqyKHQ"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;打开以后，可以看到一个简单的 Rest Client：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a rel="attachment wp-att-22615" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 14px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-22615" data-ratio="0.3541666666666667" data-type="png" data-w="2880" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzV0eS4icH2zTHpLTDgaj3t6BibbY6xAGmyqxf72PAFicHLgraDokRsRFic6w/0?wx_fmt=png" style="border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle;" title="cwYFbrpGcDIfESkDxTVb"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;之所以说它比较简单是因为个人觉得还是 Postman 更加强大，Postman 的管理功能更加强大，而 Intellij IDEA Rest Client 则缺少这样的能力。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;Hippie Completion&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这种自动补全的模式，会选择当前编辑器中适合的单词直接拿过来补全：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22616" data-ratio="0.5866666666666667" data-type="gif" data-w="1425" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_gif/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVvZCo1xNw3vb6RvLINuLCdD7tibrb0A6zZnVwKRdv7z7Biciboyf2hicwHQ/0?wx_fmt=gif" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="rCChMyJTpeNWIjbupNBj"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;粘贴版历史&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果使用过 Mac 里面的 Alfred 的话，可能大家早就习惯了 Alfred 的粘贴板历史的能力，真是复制粘贴的神器啊。其实 Intellij IDEA 里面也提供了这样的能力，我们可以直接通过 Command + Shift + V 来进行访问历史粘贴板：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22617" data-ratio="0.757026291931097" data-type="png" data-w="2206" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVufcZAm4mHaDPPz5p8hmKIsyMwXHyoyoKtUBCnJC4Xbt71ANvp1Q9HA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="jZvadtsmhPEauULAeGQn"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;Language Injection&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;大家都知道在 Java 的 String 中编辑有 JSON 的话有多麻烦，各种转义真是让人疯狂，在 Intellij IDEA 中，我们可以直接使用 Intellij IDEA 的 Language Injection 的功能（Alt + Enter）将一个字符串标记为 JSON，就可以非常方便地编写 JSON 了，再也不用担心转义的问题了：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22618" data-ratio="0.5866666666666667" data-type="gif" data-w="1425" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_gif/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzV4zSeFEGmyTDmiajprfc1PeYyiaattHVJ91eZblZqOYUVHyucm67c56fQ/0?wx_fmt=gif" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="hFqWZgnMqVBotEvcniPG"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当然，正则表达式也是支持的，甚至支持简单的正则表达式的测试能力：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a rel="attachment wp-att-22619" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 14px; color: rgb(0, 153, 204) ; ; ; ; ; ; ; ; ; "&gt;&lt;img class="alignnone size-full wp-image-22619" data-ratio="0.5866666666666667" data-type="gif" data-w="1425" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_gif/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVWn17KGibQMoxuSEibJMMviaZvAWWnNmLZVJHVibib79epouepvxPprWt2kQ/0?wx_fmt=gif" style="border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle;" title="kgYTDDUsUGJWSUpBXfZL"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;Smart Step Into&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在 Debug 的时候，如果一行代码中有多行语句，我们又需要进入其中的一个方法调用的话，经常做的方法是点开源代码，然后打上断点，或者直接右键 Run to Line，而不能使用快捷键快速将 Debug 的当前行进入到想要去的方法上，Intellij IDEA 提供了 Smart Step Into 的能力，只要使用 Shift + F7，就可以选择到底要 Debug 进入哪一个方法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="alignnone size-full wp-image-22620" data-ratio="0.5866666666666667" data-type="gif" data-w="1425" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_gif/eZzl4LXykQy16JJUQ8TjRg3XMjbialgzVu7dzZTwLvIsgZeOTyoicNhtvd3REGoATV3Zhciahqrb7BX6jibpLU3KUg/0?wx_fmt=gif" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title="DugLznKWnfYJtfQksxVx"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;以上就是我从上午的这次 Intellij IDEA 的插件的分享中学习到的一些新的 Intellij IDEA 的使用技巧，拓展了我对 Intellij IDEA 的认知，原来一个 IDE 可以做到这么智能，这么牛逼！&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;还在观望是否要使用 Intellij IDEA 的 Eclipse 的小伙伴们，赶紧弃暗投明加入 Intellij IDEA 的队伍吧，O(∩_∩)O哈哈&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1400972725741</guid></item><item><title>JVM 调优 — GC 长时间停顿问题及解决方法</title><link>http://chuansong.me/n/1400972825754</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：文牛武人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/wenniuwuren/article/details/51131741&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="jCYJcc" href="http://chuansong.me/n/351521825448" style="white-space: normal; background-color: rgb(255, 255, 255); max-width: 100%; font-size: 16px; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;零. 简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;垃圾收集器长时间停顿，表现在 Web 页面上可能是页面响应码 500 之类的服务器错误问题，如果是个支付过程可能会导致支付失败，将造成公司的直接经济损失，程序员要尽量避免或者说减少此类情况发生。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;一. 并发模式失败（concurrent mode failure）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;并发模式失败日志：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:07.974+0800: 171467.254: [GC [1 CMS-initial-mark: 1436199K(1560576K)] 1512927K(2504320K), 0.0618140 secs] [Times: user=0.06 sys=0.00, real=0.07 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:08.036+0800: 171467.316: [CMS-concurrent-mark-start]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:08.377+0800: 171467.657: [CMS-concurrent-mark: 0.340/0.340 secs] [Times: user=2.11 sys=0.15, real=0.34 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:08.377+0800: 171467.657: [CMS-concurrent-preclean-start]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:08.385+0800: 171467.665: [CMS-concurrent-preclean: 0.008/0.008 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:08.385+0800: 171467.665: [CMS-concurrent-abortable-preclean-start]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{Heap before GC invocations=88667 (full 45):  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; par new generation   total 943744K, used 914399K [0x0000000757000000, 0x0000000797000000, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  eden space 838912K, 100% used [0x0000000757000000, 0x000000078a340000, 0x000000078a340000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  from space 104832K,  72% used [0x000000078a340000, 0x000000078ecf7d98, 0x00000007909a0000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  to   space 104832K,   0% used [0x00000007909a0000, 0x00000007909a0000, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent mark-sweep generation total 1560576K, used 1436199K [0x0000000797000000, 0x00000007f6400000, 0x00000007f6400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent-mark-sweep perm gen total 159744K, used 78413K [0x00000007f6400000, 0x0000000800000000, 0x0000000800000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:09.535+0800: 171468.815: [GC2016-02-21T13:53:09.535+0800: 171468.815: [ParNew  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Desired survivor size 53673984 bytes, new threshold 6 (max 6)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   1:    7100568 bytes,    7100568 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   2:    4676456 bytes,   11777024 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   3:    8773736 bytes,   20550760 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   4:    7709744 bytes,   28260504 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   5:   10891960 bytes,   39152464 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   6:   11735032 bytes,   50887496 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;: 914399K-&amp;gt;75616K(943744K), 0.0414860 secs] 2350599K-&amp;gt;1517225K(2504320K), 0.0417710 secs] [Times: user=0.32 sys=0.05, real=0.05 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Heap after GC invocations=88668 (full 45):  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; par new generation   total 943744K, used 75616K [0x0000000757000000, 0x0000000797000000, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  eden space 838912K,   0% used [0x0000000757000000, 0x0000000757000000, 0x000000078a340000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  from space 104832K,  72% used [0x00000007909a0000, 0x0000000795378128, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  to   space 104832K,   0% used [0x000000078a340000, 0x000000078a340000, 0x00000007909a0000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent mark-sweep generation total 1560576K, used 1441609K [0x0000000797000000, 0x00000007f6400000, 0x00000007f6400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent-mark-sweep perm gen total 159744K, used 78413K [0x00000007f6400000, 0x0000000800000000, 0x0000000800000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:10.202+0800: 171469.482: [CMS-concurrent-abortable-preclean: 1.772/1.817 secs] [Times: user=4.94 sys=0.06, real=1.81 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:10.204+0800: 171469.483: [GC[YG occupancy: 497152 K (943744 K)]2016-02-21T13:53:10.204+0800: 171469.483: [Rescan (parallel) , 1.3691900 secs]2016-02-21T13:53:11.573+0800: 171470.853: [weak refs processing, 0.1009300 secs]2016-02-21T13:53:11.674+0800: 1714  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;70.954: [class unloading, 0.0153470 secs]2016-02-21T13:53:11.689+0800: 171470.969: [scrub symbol table, 0.0110770 secs]2016-02-21T13:53:11.700+0800: 171470.980: [scrub string table, 0.0016360 secs] [1 CMS-remark: 1441609K(1560576K)] 1938761K(2504320K), 1.5079530 secs] [Ti  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;mes: user=13.01 sys=0.08, real=1.51 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:11.712+0800: 171470.992: [CMS-concurrent-sweep-start]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{Heap before GC invocations=88668 (full 45):  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; par new generation   total 943744K, used 914528K [0x0000000757000000, 0x0000000797000000, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  eden space 838912K, 100% used [0x0000000757000000, 0x000000078a340000, 0x000000078a340000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  from space 104832K,  72% used [0x00000007909a0000, 0x0000000795378128, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  to   space 104832K,   0% used [0x000000078a340000, 0x000000078a340000, 0x00000007909a0000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent mark-sweep generation total 1560576K, used 1441606K [0x0000000797000000, 0x00000007f6400000, 0x00000007f6400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent-mark-sweep perm gen total 159744K, used 78413K [0x00000007f6400000, 0x0000000800000000, 0x0000000800000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-02-21T13:53:11.775+0800: 171471.055: [GC2016-02-21T13:53:11.775+0800: 171471.055: [ParNew (promotion failed)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Desired survivor size 53673984 bytes, new threshold 6 (max 6)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   1:    4030872 bytes,    4030872 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   2:    5959704 bytes,    9990576 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   3:    4628680 bytes,   14619256 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   4:    8773080 bytes,   23392336 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   5:    7707144 bytes,   31099480 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   6:   10890224 bytes,   41989704 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;: 914528K-&amp;gt;907344K(943744K), 1.0312010 secs]2016-02-21T13:53:12.807+0800: 171472.086: [CMS2016-02-21T13:53:14.455+0800: 171473.735: [CMS-concurrent-sweep: 1.684/2.743 secs] [Times: user=3.69 sys=0.36, real=2.74 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; (concurrent mode failure): 1451903K-&amp;gt;475795K(1560576K), 3.9644230 secs] 2356134K-&amp;gt;475795K(2504320K), [CMS Perm : 78413K-&amp;gt;78413K(159744K)], 4.9959570 secs] [Times: user=5.65 sys=0.34, real=5.00 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Heap after GC invocations=88669 (full 46):  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; par new generation   total 943744K, used 0K [0x0000000757000000, 0x0000000797000000, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  eden space 838912K,   0% used [0x0000000757000000, 0x0000000757000000, 0x000000078a340000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  from space 104832K,   0% used [0x000000078a340000, 0x000000078a340000, 0x00000007909a0000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  to   space 104832K,   0% used [0x00000007909a0000, 0x00000007909a0000, 0x0000000797000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent mark-sweep generation total 1560576K, used 475795K [0x0000000797000000, 0x00000007f6400000, 0x00000007f6400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent-mark-sweep perm gen total 159744K, used 78413K [0x00000007f6400000, 0x0000000800000000, 0x0000000800000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;两个原因：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;在 CMS 启动过程中，新生代提升速度过快，老年代收集速度赶不上新生代提升速度&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在 CMS 启动过程中，老年代碎片化严重，无法容纳新生代提升上来的大对象&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;发送这种情况，应用线程将会全部停止（相当于网站这段时间无法响应用户请求），进行压缩式垃圾收集（回退到 Serial Old 算法）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;新生代提升过快问题：（1）如果频率太快的话，说明空间不足，首先可以尝试调大新生代空间和晋升阈值。（2）如果内存有限，可以设置 CMS 垃圾收集在老年代占比达到多少时启动来减少问题发生频率（越早启动问题发生频率越低，但是会降低吞吐量，具体得多调整几次找到平衡点），参数如下：如果没有第二个参数，会随着 JVM 动态调节 CMS 启动时间&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:CMSInitiatingOccupancyFraction=68 （默认是 68）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;老年代碎片严重问题：（1）如果频率太快或者 Full GC 后空间释放不多的话，说明空间不足，首先可以尝试调大老年代空间（2）如果内存不足，可以设置进行 n 次 CMS 后进行一次压缩式 Full GC，参数如下：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:+UseCMSCompactAtFullCollection：允许在 Full GC 时，启用压缩式 GC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;-XX:CMSFullGCBeforeCompaction=n     在进行 n 次，CMS 后，进行一次压缩的 Full GC，用以减少 CMS 产生的碎片&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;二. 提升失败（promotion failed）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在 Minor GC 过程中，Survivor Unused 可能不足以容纳 Eden 和另一个 Survivor 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（Premature Promotion）。 这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。  再进一步， 如果老年代满了， Minor GC 后会进行 Full GC， 这将导致遍历整个堆， 称为提升失败（Promotion Failure）。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;提升失败日志：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2016-01-07T18:54:26.948+0800: 18782.967: [GC2016-04-07T18:54:26.948+0800: 18782.967: [ParNew (promotion failed)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Desired survivor size 117833728 bytes, new threshold 10 (max 10)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   1:    6141680 bytes,    6141680 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   2:    6337936 bytes,   12479616 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   3:     549120 bytes,   13028736 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   4:      87768 bytes,   13116504 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   5:     221384 bytes,   13337888 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   6:     934168 bytes,   14272056 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   7:     146072 bytes,   14418128 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   8:     626064 bytes,   15044192 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age   9:     398000 bytes,   15442192 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;- age  10:     429616 bytes,   15871808 total  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;: 1969227K-&amp;gt;1929200K(2071808K), 0.7452140 secs]2016-01-07T18:54:27.693+0800: 18783.713: [CMS: 1394703K-&amp;gt;632845K(2097152K), 4.0993640 secs] 3301676K-&amp;gt;632845K(4168960K), [CMS Perm : 77485K-&amp;gt;77473K(159744K)], 4.8450240 secs] [Times: user=5.18 sys=0.56, real=4.84 secs]  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Heap after GC invocations=5847 (full 7):  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; par new generation   total 2071808K, used 0K [0x00000006e9c00000, 0x0000000776400000, 0x0000000776400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  eden space 1841664K,   0% used [0x00000006e9c00000, 0x00000006e9c00000, 0x000000075a280000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  from space 230144K,   0% used [0x0000000768340000, 0x0000000768340000, 0x0000000776400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  to   space 230144K,   0% used [0x000000075a280000, 0x000000075a280000, 0x0000000768340000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent mark-sweep generation total 2097152K, used 632845K [0x0000000776400000, 0x00000007f6400000, 0x00000007f6400000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; concurrent-mark-sweep perm gen total 159744K, used 77473K [0x00000007f6400000, 0x0000000800000000, 0x0000000800000000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;提升失败原因：Minor GC 时发现 Survivor 空间放不下，而老年代的空闲也不够&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;新生代提升太快&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;老年代碎片太多，放不下大对象提升（表现为老年代还有很多空间但是，出现了 promotion failed）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;解决方法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;两条和上面 concurrent mode failure 一样&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 另一条，是因为 Survivor Unused 不足，那么可以尝试调大 Survivor 来尝试下&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;三. 在 GC 的时候其他系统活动影响&lt;/span&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;有些时候系统活动诸如内存换入换出（vmstat）、网络活动（netstat）、I/O （iostat）在 GC 过程中发生会使 GC 时间变长。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;前提是你的服务器上是有 SWAP 区域（用 top、 vmstat 等命令可以看出）用于内存的换入换出，那么操作系统可能会将 JVM 中不活跃的内存页换到 SWAP 区域用以释放内存给线程使用（这也透露出内存开始不够用了）。内存换入换出是一个开销巨大的磁盘操作，比内存访问慢好几个数量级。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;看一段 GC 日志：耗时 29.47 秒&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{Heap before GC invocations=132 (full 0):  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;par new generation total 2696384K, used 2696384K [0xfffffffc20010000, 0xfffffffce0010000, 0xfffffffce0010000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;eden space 2247040K, 100% used [0xfffffffc20010000, 0xfffffffca9270000, 0xfffffffca9270000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;from space 449344K, 100% used [0xfffffffca9270000, 0xfffffffcc4940000, 0xfffffffcc4940000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;to space 449344K, 0% used [0xfffffffcc4940000, 0xfffffffcc4940000, 0xfffffffce0010000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;concurrent mark-sweep generation total 9437184K, used 1860619K [0xfffffffce0010000, 0xffffffff20010000, 0xffffffff20010000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;concurrent-mark-sweep perm gen total 1310720K, used 511451K [0xffffffff20010000, 0xffffffff70010000, 0xffffffff70010000)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;2013-07-17T03:58:06.601-0700: 51522.120: [GC Before GC: : 2696384K-&amp;gt;449344K(2696384K), 29.4779282 secs] 4557003K-&amp;gt;2326821K(12133568K) ,29.4795222 secs] [Times: user=915.56 sys=6.35, real=29.48 secs]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;再看看此时的 vmstat 命令中 si、so 列的数值，如果数值大说明换入换出严重，这是内存不足的表现。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;解决方法：减少线程，这样可以降低内存换入换出；增加内存；如果是 JVM 内存设置过大导致线程所用内存不足，则适当调低 -Xmx 和 -Xms。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;四. JVM 的 bug&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这种原因就根据自己使用的 JDK 版本去查一下，如果是 JVM 的 bug，升级到解决的版本一般就能解决。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;五. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;长时间停顿问题的排查及解决首先需要一定的信息和方法论：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;详细的 GC 日志&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;借助 Linux 平台下的 iostat、vmstat、netstat、mpstat 等命令监控系统情况&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 GCHisto 这个 GC 图形用户界面工具，可以统计出 Minor GC 及 Full GC 频率及时长分布，可参考:http://blog.csdn.net/wenniuwuren/article/details/50760259&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看 GC 日志中是否出现了上述的典型内存异常问题（promotion failed, concurrent mode failure），整体来说把上述两个典型内存异常情况控制在可接受的发生频率即可，对 CMS 碎片问题来说杜绝以上问题似乎不太可能，只能靠 G1 来解决了&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是不是 JVM 本身的 bug 导致的&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果程序没问题，参数调了几次还是不能解决，可能说明流量太大，需要加机器把压力分散到更多 JVM 上&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;六. 参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;Java 性能优化权威指南&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://blogs.oracle.com/poonam/entry/troubleshooting_long_gc_pauses&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1400972825754</guid></item><item><title>Spring 核心框架体系结构</title><link>http://chuansong.me/n/1392716225831</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：凌承一&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：www.cnblogs.com/ywlaker/p/6136625.html&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="BfuJcc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; white-space: normal; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;欢迎投稿，请点击这里查看详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;很多人都在用spring开发java项目，但是配置maven依赖的时候并不能明确要配置哪些spring的jar，经常是胡乱添加一堆，编译或运行报错就继续配置jar依赖，导致spring依赖混乱，甚至下一次创建相同类型的工程时也不知道要配置哪些spring的依赖，只有拷贝，其实，当初我就是这么干的！&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;spring的jar包只有20个左右，每个都有相应的功能，一个jar还可能依赖了若干其他jar，所以，搞清楚它们之间的关系，配置maven依赖就可以简洁明了，下面举个例子，要在普通java工程使用spring框架，需要哪些jar呢？只要一个&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;&lt;dependency&gt;&lt;/dependency&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;groupid&gt;org.springframework&lt;/groupid&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;artifactid&gt;spring-context&lt;/artifactid&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;version&gt;3.2.17.RELEASE&lt;/version&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1392716225831</guid></item><item><title>JAVA 虚拟机关闭钩子 ( Shutdown Hook )</title><link>http://chuansong.me/n/1392716325844</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：朱小厮&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/u013256816/article/details/50394923&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;a csmlink="DfuJcc" href="http://chuansong.me/n/351521825448" style="max-width: 100%; font-size: 16px; white-space: normal; box-sizing: border-box !important; word-wrap: break-word !important;" target="_blank"&gt;&lt;span style="max-width: 100%; color: rgb(0, 82, 255); font-size: 14px; line-height: 1.6; box-sizing: border-box !important; word-wrap: break-word !important; overflow-wrap: break-word !important;"&gt;欢迎投稿，请点击这里查看详情&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;Java程序经常也会遇到进程挂掉的情况，一些状态没有正确的保存下来，这时候就需要在JVM关掉的时候执行一些清理现场的代码。JAVA中的ShutdownHook提供了比较好的方案。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JDK提供了Java.Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的钩子，这个钩子可以在一下几种场景中被调用：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style="list-style-type: decimal;"&gt;&lt;li&gt;&lt;p&gt;程序正常退出&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用System.exit()&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;终端使用Ctrl+C触发的中断&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统关闭&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OutOfMemory宕机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用Kill pid命令干掉进程（注：在使用kill -9 pid时，是不会被调用的）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面是JDK1.7中关于钩子的定义：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void addShutdownHook(Thread hook)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;参数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    hook - An initialized but unstarted Thread object &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;抛出： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    IllegalArgumentException - If the specified hook has already been registered, or if it can be determined that the hook is already running or has already been run &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    IllegalStateException - If the virtual machine is already in the process of shutting down &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    SecurityException - If a security manager is present and it denies RuntimePermission("shutdownHooks")&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;从以下版本开始： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    1.3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;另请参见：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    removeShutdownHook(java.lang.Thread), halt(int), exit(int)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;首先来测试第一种，程序正常退出的情况：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.hook;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.util.concurrent.TimeUnit;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class HookTest  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void start()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            @Override &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            public void run()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                System.out.println("Execute Hook.....");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }));  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        new HookTest().start();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println("The Application is doing something");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        try &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            TimeUnit.MILLISECONDS.sleep(5000);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        catch (InterruptedException e)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            e.printStackTrace();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;The Application is doing something  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Execute Hook.....&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如上可以看到，当main线程运行结束之后就会调用关闭钩子。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;下面再来测试第五种情况（顺序有点乱，表在意这些细节）：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.hook;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.util.concurrent.TimeUnit;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class HookTest2  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void start()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            @Override &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            public void run()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                System.out.println("Execute Hook.....");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }));  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        new HookTest().start();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        System.out.println("The Application is doing something");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        byte[] b = new byte[500*1024*1024];  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        try &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            TimeUnit.MILLISECONDS.sleep(5000);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        catch (InterruptedException e)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            e.printStackTrace();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行参数设置为：-Xmx20M  这样可以保证会有OutOfMemoryError的发生。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;The Application is doing something  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Exception in thread "main" java.lang.OutOfMemoryError: Java heap space  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    at com.hook.HookTest2.main(HookTest2.java:22)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;Execute Hook.....&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以看到程序遇到内存溢出错误后调用关闭钩子，与第一种情况中，程序等待5000ms运行结束之后推出调用关闭钩子不同。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;接下来再来测试第三种情况：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;package com.hook;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;import java.util.concurrent.TimeUnit;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class HookTest3  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;{  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void start()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            @Override &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            public void run()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                System.out.println("Execute Hook.....");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }));  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static void main(String[] args)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        new HookTest3().start();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Thread thread = new Thread(new Runnable(){  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            @Override &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            public void run()  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                while(true)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    System.out.println("thread is running....");  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    try &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        TimeUnit.MILLISECONDS.sleep(100);  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    catch (InterruptedException e)  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    {  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                        e.printStackTrace();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        });  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        thread.start();  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在命令行中编译：javac com/hook/HookTest3.java&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在命令行中运行：Java com.hook.HookTest3  （之后按下Ctrl+C）&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.4520547945205479" data-type="png" data-w="511" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQyZ9rd8iaof71hj5mHm1LVxYIIa0JQ9v3uBTdxMmt2p2wVd6YsWNfiaOJDb6IMsW9U50ia81LckJa6VA/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;可以看到效果如预期。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;还有几种情况就不一一列出了，有兴趣的读者可以试一下。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1392716325844</guid></item><item><title>使用 Spring Boot 开发 Web 项目</title><link>http://chuansong.me/n/1387968225936</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：sang&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/u012702547/article/details/53784992&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;前面两篇博客中我们简单介绍了spring Boot项目的创建、并且也带小伙伴们来DIY了一个Spring Boot自动配置功能，那么这些东西说到底最终还是要回归到Web上才能体现出它的更大的价值，so，今天我们就来看一下如何使用Spring Boot来开发Web项目。当然，如果小伙伴对Spring Boot尚不熟悉的话，可以先参考一下这两篇博客：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;1. 初识Spring Boot框架&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;http://blog.csdn.net/u012702547/article/details/53740047&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2. 初识Spring Boot框架(二)之DIY一个Spring Boot的自动配置&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;http://blog.csdn.net/u012702547/article/details/53750449&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;Spring Boot 提供了spring-boot-starter-web来为Web开发予以支持，spring-boot-starter-web为我们提供了嵌入的Tomcat以及SpringMVC的依赖，用起来很方便。另外，我们这里还要用到模板引擎，我们做web开发可选的模板引擎还是挺多的，这里我主要使用Thymeleaf作为模板引擎，事实上，Spring Boot提供了大量的模板引擎，包括FreeMarker、Groovy、Thymeleaf、Velocity和Mustache，在 提供的这么多中它推荐使用Thymeleaf。Thymeleaf在使用的过程中通过ThymeleafAutoConfiguration类对集成所需要的Bean进行自动配置，通过ThymeleafProperties来配置Thymeleaf，包括前缀后缀什么的，我们可以查看ThymeleafProperties一段源码：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;@ConfigurationProperties("spring.thymeleaf")&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class ThymeleafProperties {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static final String DEFAULT_PREFIX = "classpath:/templates/";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public static final String DEFAULT_SUFFIX = ".html";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private boolean checkTemplate = true;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private boolean checkTemplateLocation = true;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private String prefix = "classpath:/templates/";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private String suffix = ".html";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private String mode = "HTML5";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    ......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    ......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    ......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: justify;"&gt;OK，从这一段源码中我们可以看到默认的页面后缀名为.html，前缀为classpath:/templates/，实际上也就是我们需要把html页面放到resources文件夹下的templates文件夹中。同时我们也看到了要如何修改这个配置，在application.properties文件中以spring.thymeleaf为前缀来配置相关属性。&lt;/p&gt;&lt;p style="text-align: justify;"&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: left;"&gt;关于Thymeleaf如果小伙伴们还不太了解可以先看看我在网上找到的这个资料Thymeleaf中文文档最新版（http://download.csdn.net/download/u013285335/9608648）。OK，这些算是准备工作了。接下来我们就从项目的创建开始看起吧。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;创建Project&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;注意创建的时候要选择Thymeleaf作为依赖，这样创建成功的Project中将自动包含spring-boot-starter-web，如下图：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;br style="  ; ; ; ; ; ; ; ; ; "/&gt;&lt;img class="" data-ratio="0.8017524644030668" data-type="png" data-w="913" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQyBYUddXrvnZjpzQQdo621uKhMQxwvL6cKdeu070s1ibicJrK73TibaCxiaH9J6Zic62WoEkoSTHJ83slg/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title=""/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;创建JavaBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我一会要从后台传递数据给前台页面，数据的载体就是这个JavaBean，如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public class Person {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private String name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private Integer age;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public Person() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        super();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public Person(String name, Integer age) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        super();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        this.name = name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        this.age = age;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public String getName() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void setName(String name) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        this.name = name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public Integer getAge() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return age;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public void setAge(Integer age) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        this.age = age;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;后台数据构造&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在入口类中添加如下代码，由后台向前台页面返回两条数据，一个单个的Person对象，还有一个people对象是一个List集合，集合中放了3个Person对象，到时候我们直接将这两条数据在html页面上显示出来，代码如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;@RequestMapping("/")&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public String index(Model model) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Person single = new Person("aa", 11);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        List&lt;person&gt; people = new ArrayList&amp;lt;&amp;gt;();&lt;/person&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Person p1 = new Person("zhangsan", 11);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Person p2 = new Person("lisi", 22);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        Person p3 = new Person("wangwu", 33);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        people.add(p1);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        people.add(p2);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        people.add(p3);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        model.addAttribute("singlePerson", single);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        model.addAttribute("people", people);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return "index";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这里的代码都很简单，不必我多说了，就是返回给前台页面两个对象，一个singlePerson，一个people，另外，我们的前台页面叫做index.html。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;引入相关的静态文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这里我使用到了Bootstrap和jQuery两个库，当然这个并不是必须的，只是为了让我们显示的效果更好看一些,静态文件我们要放在src/main/resources/static目录下。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;1. Bootstrap下载&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;http://v3.bootcss.com/getting-started/#download&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;2.jQuery下载&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;http://jquery.com/download/&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;放置之后目录如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;br style="  ; ; ; ; ; ; ; ; ; "/&gt;&lt;img class="" data-ratio="0.5614617940199336" data-type="png" data-w="301" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQyBYUddXrvnZjpzQQdo621uZCaogmibGiczGyPnaUb3hunKBlFjVOxszDMiaiaWmibQUGlCYo5DOJIyGBg/0?wx_fmt=png" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; " title=""/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span style="color: rgb(255, 76, 65);"&gt;前台展示页面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;刚才小伙伴们都看到了，默认情况下前台页面要放在src/main/resources/templates目录下，so，我们在该目录下新建文件就叫index.html,如下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;/html&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;&lt;head&gt;&lt;/head&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;meta charset="utf-8"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;title&gt;Test20&lt;/title&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;link rel="stylesheet" th:href="@{bootstrap/css/bootstrap.min.css}"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    &lt;link rel="stylesheet" th:href="@{bootstrap/css/bootstrap-theme.min.css}"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1387968225936</guid></item><item><title>Java 枚举与字符串的转换</title><link>http://chuansong.me/n/1387968325932</link><description>&lt;div class="rich_media_content " id="js_content"&gt;
&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;（点击&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; font-size: 14px; line-height: 22.4px; color: rgb(0, 128, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;上方公众号&lt;/span&gt;&lt;span style="max-width: 100%; white-space: pre-wrap; color: rgb(255, 41, 65); font-size: 14px; line-height: 22.4px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;，可快速关注）&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;br style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(136, 136, 136); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;来源：xieyu_zy&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; line-height: 25.6px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(136, 136, 136); font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;链接：blog.csdn.net/xieyuooo/article/details/8483267&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;文章简单，相信在很多网站都能搜索到java enum枚举的使用方式；可能有些东西我当时在刚开始用的时候没找到，所以我写了这篇文章，例如：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;大多数地方写的枚举都是给一个枚举然后例子就开始switch，可是我想说，我代码里头来源的数据不太可能就是枚举，通常是字符串或数字，比如一个SQL我解析后首先判定SQL类型，通过截取SQL的token，截取出来可能是SELECT、DELETE、UPDATE、INSERT、ALTER等等，但是都是字符串，此时我想用枚举就不行了，我要将字符串转换成枚举怎么转呢，类似的情况还有从数据库取出数据根据一些类型做判定，从页面传入数据，根据不同的类型做不同的操作，但是都是字符串，不是枚举，悲剧的是我很少看到有人写到这个东西；所以我把它写下来，希望有人能用到。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;首先为什么要用枚举？我们在什么时候用枚举比较好，用枚举有啥优势？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我认为哈，当你在一些一个范畴类，并可列举，不变化的类型，用以指导程序向不同的地方路由，用枚举是较好的选择；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;听起来有点绕，不过有个例子也许可以明白，例如：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们可以列举下日常工作日所做的事情：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;上班、开会、吃饭、睡觉等&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们可以列举医院五官科需要检查人的部位：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;眼睛、鼻子、耳朵、嘴巴等&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这些都是可以被列举的，且每种事情我们要用不同的方式去做；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当然你可以说：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;1、可以用动态方法分派，通过配置文件或annotation；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;2、可以使用常量来达到类似的效果；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;3、直接通过字符串的equals来表达，用if else来表达&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果用配置加方法分派来做，是灵活，便于修改；但是如果在很多不经常修改的参数上，我们用这中方式往往增加配置的负担，并且当你需要看系统逻辑的时候，需要需要一遍看配置一遍看代码；不过，如果参数是可动态变换的信息，用配置是正确的选择；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;而常量的使用，通常在switch case的时候都是数字，字符串在java中是不能做switch case的，使用常量的目的比case 1、case 2 …这种增加了可读性；但是字符串数据也麻烦，除非再映射一次，那没那个必要，其实枚举也差不多是帮你映射了一次，只是它将代码封装了而已吧了，既然他弄好了，而且语法上支持，干嘛不用呢！其次，常量虽然增加了可读性，不过他没有范畴和管理类型的概念，即一个枚举的定义会定义个范畴，可以很好的将这个范围所需要的东西列举出来，而常量通常是些自己定义的一些池，放在一些公共类中或随机定义，都是比较零散的，并且枚举在switch的时候就明确定义好了就在锁列举的范围内case，既可以控制好系统，增加可读性，并且可以随时查看这个范畴的枚举信息到底有那些，达到类似看配置文件的作用；不过还是回到那句话，如果参数是可变的，那么就不适合做枚举，枚举是一定是可列举的，或者说当前系统考虑范围是可以被枚举的，例如上面的医院五官科，可能还有很多没有列举到，但是当前医院只处理几个部位，不处理其他的，就是这个道理；什么是可变的呢，例如URL参数来分派到对应方法，不可能大家加一段逻辑就去加一个枚举，加一个case，此时用【配置+动态方法分派】更好，当然配置可以用文件或annotation而已。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;还有最土的就是，通过字符串equals，用if else来实现，呵呵，这个并没有什么不好，只是这个写比较零散，其次，字符串匹配的equals每次匹配都需要对比每个字符，如果你的代码中大量循环，性能并不是很好，其余的看看上面的描述就更加清楚了；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其次，枚举提供一种类型管理的组件，让面向对象的体系更加完善，使得一些类型的管理既可配置化，并可以管理，在使用枚举的地方都可以沿着枚举的定义找到那些有处理过，那些没处理过，而上述几种很难做到；例如，数据库的操作类型定义了10种，那么再判定的过程中就可以讲枚举像配置文件一样看待，而又非常简单的来管理。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;最后，枚举绝对是单例的，对比的性能和数字性能相当，既可以得到可读性，也可以得到性能。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们先定义个简单枚举(这里只是个例子，就简单定义3个变量了)：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public enum SqlTypeEnum {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    INSERT , &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    UPDATE ,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    DELETE ,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    SELECT&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;此时解析SQL后，获取出来一个token，我们要获取这个token的枚举怎么获取呢？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;这样获取：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;String token = "select";&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;SqlTypeEnum sqlTypeEnum = SqlTypeEnum.valueOf(token.toUpperCase());&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;如果没获取到，java会抛出一个异常哦：IllegalArgumentException No enum const class SqlTypeEnum.XXX&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我做大写处理的原因是因为枚举也是大写的（当然如果你的枚举是小写的，那你就小写，不过混写比较麻烦哈），其实valueOf就是调用了枚举的底层映射：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.4991304347826087" data-type="jpeg" data-w="575" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQyBYUddXrvnZjpzQQdo621uImWYHQR1owYGGZcKhAoAC8GgXIR0TDBDkXERWyf5ry4W8FKQwNKEyw/0?wx_fmt=jpeg" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;调用的时候会调用这个方法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;img class="" data-ratio="0.4175152749490835" data-type="jpeg" data-w="491" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQyBYUddXrvnZjpzQQdo621uTWofpFtYMKSrpL5OfqX0UrGtbW1dQptmw5s5maEnrOl5fm47wjnJvg/0?wx_fmt=jpeg" style=" border-width: 0px; border-style: initial; border-color: initial; font-size: 0px; color: transparent; vertical-align: middle ; ; ; ; ; ; ; ; ; "/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;所以内部也是一个HashMap，呵呵！&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;拿到这个信息后，就可以做想要的操作了:&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;switch(sqlTypeEnum) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  case INSERT:处理insert逻辑;break;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  case DELETE:处理delete逻辑;break;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; ....&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;OK，有些时候可能我们不想直接用INSERT、UPDATE这样的字符串在交互中使用，因为很多时候命名规范的要求；&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;例如定义一些用户操作类型：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;1、保存用户信息&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;2、通过ID获取用户基本信息&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;3、获取用户列表&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;4、通过ID删除用户信息&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;等等&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们可能定义枚举会定义为：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public enum UserOptionEnum {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    SAVE_USER,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    GET_USER_BY_ID,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    GET_USER_LIST,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    DELETE_USER_BY_ID&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;但是系统的方法和一些关键字的配置，通常会写成：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;saveUser、getUserById、getUserById、deleteUserById&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;当然各自有各自的规则，不过中间这层映射，你不想做，就一方面妥协，要么枚举名称全部换掉，貌似挺奇怪的，要么方法名称全部换掉，更加奇怪，要么自己做映射，可以，稍微麻烦点，其实也不麻烦？&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们首先写个将枚举下划线风格的数据转换为驼峰的方法，放在一个StringUtils里面：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public static String convertDbStyleToJavaStyle(String dbStyleString , boolean firstUpper) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        dbStyleString = dbStyleString.toLowerCase();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        String []tokens = dbStyleString.split("_");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        StringBuilder stringBuilder = new StringBuilder(128);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        int length = 0;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        for(String token : tokens) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            if(StringUtils.isNotBlank(token)) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                if(length == 0 &amp;amp;&amp;amp; !firstUpper) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    stringBuilder.append(token);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                }else {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    char c = token.charAt(0);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    if(c &amp;gt;= 'a' || c &amp;lt;= 'z') c = (char)(c - 32);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    stringBuilder.append(c);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                    stringBuilder.append(token.substring(1));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;                }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            ++length;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return stringBuilder.toString();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;重载一个方法：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public static String convertDbStyleToJavaLocalStyle(String dbStyleString) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return convertDbStyleToJavaStyle(dbStyleString , false);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;然后定义枚举：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public enum UserOptionEnum {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    SAVE_USER,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    GET_USER_BY_ID,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    GET_USER_LIST,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    DELETE_USER_BY_ID;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    private final static Map&lt;string ,="" useroptionenum=""&gt; ENUM_MAP = new HashMap&lt;string, useroptionenum=""&gt;(64);&lt;/string,&gt;&lt;/string&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    static {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        for(UserOptionEnum v : values()) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;            ENUM_MAP.put(v.toString() , v); &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public staticUserOptionEnum fromString(String v) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        UserOptionEnum userOptionEnum = ENUM_MAP.get(v);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return userOptionEnum == null ? DEFAULT :userOptionEnum;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    public String toString() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        String stringValue = super.toString();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        return StringUtil.convertDbStyleToJavaLocalStyle(stringValue);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;OK，这样传递一个event参数让如果是：saveUser，此时就用：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;String event = "saveUser";//假如这里得到参数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;UserOptionEnum enum = UserOptionEnum.fromString(event);&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其实就是自己做了一个hashMap，我这加了一个fromString，因为枚举有一些限制，有些方法不让你覆盖，比如valueOf方法就是这样。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;其实没啥好讲的了，非要说，再说说枚举加一些自定义变量吧，其实枚举除了是单例的外，其余的和普通类也相似，它也可以有构造方法，只是默认情况下不是而已，也可以提供自定义的变量，然后获取set、get方法，但是如果有set的话，线程不是安全的哦，要注意这点；所以一般是构造方法就写好了：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;public enum SqlTypeEnum {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   INSERT("insert into"),&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   DELETE("delete from")&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   ......省略;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   private String name;//定义自定义的变量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   private SqlTypeEnum(String name) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;      this.name = name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   public String getName() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       return name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;   public String toString() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;       return name + " 我靠";//重写toString方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  //一般不推荐&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  public void setName(String name) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;        this.name = name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;  }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;调用下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;SqlTypeEnum sqlTypeEnum = SqlTypeEnum.valueOf("INSERT");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println(sqlTypeEnum);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println(sqlTypeEnum.getName());&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;不推荐也调用下：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;sqlTypeEnum.setName("我靠");&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;在另一个线程：&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;SqlTypeEnum sqlTypeEnum = SqlTypeEnum.valueOf("INSERT");&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println(sqlTypeEnum);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="font-size: 12px; color: rgb(136, 136, 136);"&gt;System.out.println(sqlTypeEnum.getName());&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;发现结果被改了，呵呵！&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; font-size: 14px; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; text-align: center; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span style="max-width: 100%; color: rgb(255, 169, 0); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;strong style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;关注「ImportNew」，看技术干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img data-ratio="0.9166666666666666" data-s="300,640" data-type="png" data-w="600" src="http://read.html5.qq.com/image?src=forum&amp;amp;q=5&amp;amp;r=0&amp;amp;imgflag=7&amp;amp;imageUrl=http://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=png" style="box-sizing: border-box !important; word-wrap: break-word !important; visibility: visible !important; width: 600px !important;" width="auto"/&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid isPermaLink="false">http://chuansong.me/n/1387968325932</guid></item></channel></rss>